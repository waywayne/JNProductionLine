import 'package:flutter/material.dart';
import 'dart:async';
import 'dart:typed_data';
import '../services/serial_service.dart';
import '../services/production_test_commands.dart';
import '../services/gtp_protocol.dart';
import 'log_state.dart';
import '../config/test_config.dart';
import '../config/wifi_config.dart';
import '../config/sn_mac_config.dart';
import 'touch_test_step.dart';

enum TestStatus {
  waiting,
  testing,
  pass,
  fail,
  timeout,
  error,
}

class TestItem {
  final String name;
  final String method;
  final String result;
  final Color backgroundColor;
  final TestStatus status;
  final String? errorMessage;

  TestItem({
    required this.name,
    required this.method,
    required this.result,
    required this.backgroundColor,
    this.status = TestStatus.waiting,
    this.errorMessage,
  });

  TestItem copyWith({
    String? name,
    String? method,
    String? result,
    Color? backgroundColor,
    TestStatus? status,
    String? errorMessage,
  }) {
    return TestItem(
      name: name ?? this.name,
      method: method ?? this.method,
      result: result ?? this.result,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      status: status ?? this.status,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }
}

enum WiFiStepStatus {
  waiting,
  testing,
  success,
  failed,
  timeout,
}

class WiFiTestStep {
  final int opt;
  final String name;
  final String description;
  WiFiStepStatus status;
  String? errorMessage;
  int currentRetry;
  final int maxRetries;
  List<int>? data;
  Map<String, dynamic>? result;

  WiFiTestStep({
    required this.opt,
    required this.name,
    required this.description,
    this.status = WiFiStepStatus.waiting,
    this.errorMessage,
    this.currentRetry = 0,
    this.maxRetries = 10,
    this.data,
    this.result,
  });

  WiFiTestStep copyWith({
    WiFiStepStatus? status,
    String? errorMessage,
    int? currentRetry,
    Map<String, dynamic>? result,
  }) {
    return WiFiTestStep(
      opt: opt,
      name: name,
      description: description,
      status: status ?? this.status,
      errorMessage: errorMessage ?? this.errorMessage,
      currentRetry: currentRetry ?? this.currentRetry,
      maxRetries: maxRetries,
      data: data,
      result: result ?? this.result,
    );
  }
}

class TestGroup {
  final String name;
  final List<TestItem> items;

  TestGroup({
    required this.name,
    required this.items,
  });
}

class TestState extends ChangeNotifier {
  String _testScriptPath = 'Choose script file path';
  String _configFilePath = 'Choose config file path';

  final SerialService _serialService = SerialService();
  String? _selectedPort;
  bool _isRunningTest = false;
  bool _shouldStopTest = false; // æµ‹è¯•åœæ­¢æ ‡å¿—

  // å•ä¸ªæµ‹è¯•ç»„ï¼Œé»˜è®¤ä¸ºç©º
  TestGroup? _currentTestGroup;

  // æ—¥å¿—çŠ¶æ€
  LogState? _logState;

  // MIC çŠ¶æ€è·Ÿè¸ª (true = å·²å¼€å¯, false = å·²å…³é—­)
  final Map<int, bool> _micStates = {
    0: false, // MIC0
    1: false, // MIC1
    2: false, // MIC2
  };

  // LED çŠ¶æ€è·Ÿè¸ª (true = å·²å¼€å¯, false = å·²å…³é—­)
  final Map<int, bool> _ledStates = {
    ProductionTestCommands.ledOuter: false, // LED0(å¤–ä¾§)
    ProductionTestCommands.ledInner: false, // LED1(å†…ä¾§)
  };

  // å½“å‰è®¾å¤‡æ ‡è¯†ä¿¡æ¯
  Map<String, String>? _currentDeviceIdentity;

  // WiFiæµ‹è¯•æ­¥éª¤çŠ¶æ€
  List<WiFiTestStep> _wifiTestSteps = [];
  
  // Touchæµ‹è¯•æ­¥éª¤çŠ¶æ€
  List<TouchTestStep> _leftTouchTestSteps = [];
  List<TouchTestStep> _rightTouchTestSteps = [];
  bool _isLeftTouchTesting = false;
  bool _isRightTouchTesting = false;
  int? _baselineCdcValue; // æœªè§¦æ‘¸æ—¶çš„åŸºçº¿CDCå€¼
  
  // Touchæµ‹è¯•å¼¹çª—çŠ¶æ€
  bool _showTouchDialog = false;
  bool _isLeftTouchDialog = false;
  
  // Sensoræµ‹è¯•çŠ¶æ€
  bool _isSensorTesting = false;
  bool _showSensorDialog = false;
  List<Map<String, dynamic>> _sensorDataList = [];
  StreamSubscription<Uint8List>? _sensorDataSubscription;
  
  // Sensorå›¾ç‰‡æ•°æ®æ‹¼æ¥çŠ¶æ€
  int? _expectedTotalBytes;
  List<int> _imageBuffer = [];
  DateTime? _lastPacketTime;
  Timer? _sensorTimeoutTimer;
  Timer? _packetTimeoutTimer;
  int _sensorRetryCount = 0;

  // IMUæµ‹è¯•çŠ¶æ€
  bool _isIMUTesting = false;
  bool _showIMUDialog = false;
  List<Map<String, dynamic>> _imuDataList = [];
  StreamSubscription<Uint8List>? _imuDataSubscription;

  String get testScriptPath => _testScriptPath;
  String get configFilePath => _configFilePath;
  TestGroup? get currentTestGroup => _currentTestGroup;
  bool get isConnected => _serialService.isConnected;
  String? get selectedPort => _selectedPort;
  bool get isRunningTest => _isRunningTest;

  List<String> get availablePorts => SerialService.getAvailablePorts();
  
  // è·å–å½“å‰è®¾å¤‡æ ‡è¯†ä¿¡æ¯
  Map<String, String>? get currentDeviceIdentity => _currentDeviceIdentity;

  // è·å–WiFiæµ‹è¯•æ­¥éª¤
  List<WiFiTestStep> get wifiTestSteps => _wifiTestSteps;
  
  // è·å–Touchæµ‹è¯•æ­¥éª¤
  List<TouchTestStep> get leftTouchTestSteps => _leftTouchTestSteps;
  List<TouchTestStep> get rightTouchTestSteps => _rightTouchTestSteps;
  bool get isLeftTouchTesting => _isLeftTouchTesting;
  bool get isRightTouchTesting => _isRightTouchTesting;
  int? get baselineCdcValue => _baselineCdcValue;
  
  // è·å–Touchæµ‹è¯•å¼¹çª—çŠ¶æ€
  bool get showTouchDialog => _showTouchDialog;
  bool get isLeftTouchDialog => _isLeftTouchDialog;
  
  // è·å–Sensoræµ‹è¯•çŠ¶æ€
  bool get isSensorTesting => _isSensorTesting;
  bool get showSensorDialog => _showSensorDialog;
  List<Map<String, dynamic>> get sensorDataList => _sensorDataList;

  // è·å–IMUæµ‹è¯•çŠ¶æ€
  bool get isIMUTesting => _isIMUTesting;
  bool get showIMUDialog => _showIMUDialog;
  List<Map<String, dynamic>> get imuDataList => _imuDataList;

  // è·å– MIC çŠ¶æ€
  bool getMicState(int micNumber) => _micStates[micNumber] ?? false;

  // è·å– LED çŠ¶æ€
  bool getLedState(int ledNumber) => _ledStates[ledNumber] ?? false;

  void setLogState(LogState logState) {
    _logState = logState;
    _serialService.setLogState(logState);
  }
  
  /// å…³é—­Touchæµ‹è¯•å¼¹çª—
  void closeTouchDialog() {
    _showTouchDialog = false;
    notifyListeners();
  }

  void setTestScriptPath(String path) {
    _testScriptPath = path;
    notifyListeners();
  }

  void setConfigFilePath(String path) {
    _configFilePath = path;
    notifyListeners();
  }

  /// åˆå§‹åŒ–SN/MACé…ç½®
  Future<void> initializeSNMacConfig() async {
    try {
      await SNMacConfig.initialize();
      _logState?.info('SN/MACé…ç½®åˆå§‹åŒ–æˆåŠŸ');
    } catch (e) {
      _logState?.error('SN/MACé…ç½®åˆå§‹åŒ–å¤±è´¥: $e');
    }
  }

  /// ç”Ÿæˆæ–°çš„è®¾å¤‡æ ‡è¯†ä¿¡æ¯
  Future<void> generateDeviceIdentity() async {
    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ·ï¸  å¼€å§‹ç”Ÿæˆè®¾å¤‡æ ‡è¯†ä¿¡æ¯', type: LogType.debug);
      
      _currentDeviceIdentity = await SNMacConfig.generateDeviceIdentity();
      
      _logState?.info('âœ… è®¾å¤‡æ ‡è¯†ä¿¡æ¯ç”ŸæˆæˆåŠŸ:', type: LogType.debug);
      _logState?.info('   ğŸ“‹ SNç : ${_currentDeviceIdentity!['sn']}', type: LogType.debug);
      _logState?.info('   ğŸ“¡ WiFi MAC: ${_currentDeviceIdentity!['wifiMac']}', type: LogType.debug);
      _logState?.info('   ğŸ“¶ è“ç‰™ MAC: ${_currentDeviceIdentity!['bluetoothMac']}', type: LogType.debug);
      _logState?.info('   ğŸ­ äº§å“çº¿: ${_currentDeviceIdentity!['productLine']}', type: LogType.debug);
      _logState?.info('   ğŸ¢ å·¥å‚: ${_currentDeviceIdentity!['factory']}', type: LogType.debug);
      _logState?.info('   ğŸ“… ç”Ÿäº§æ—¥æœŸ: ${_currentDeviceIdentity!['productionDate']}', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      
      notifyListeners();
    } catch (e) {
      _logState?.error('ç”Ÿæˆè®¾å¤‡æ ‡è¯†ä¿¡æ¯å¤±è´¥: $e', type: LogType.debug);
    }
  }

  /// è®¾ç½®äº§å“çº¿
  Future<void> setProductLine(String productLine) async {
    try {
      await SNMacConfig.setProductLine(productLine);
      _logState?.info('äº§å“çº¿è®¾ç½®ä¸º: $productLine');
      notifyListeners();
    } catch (e) {
      _logState?.error('è®¾ç½®äº§å“çº¿å¤±è´¥: $e');
    }
  }

  /// è®¾ç½®å·¥å‚
  Future<void> setFactory(String factory) async {
    try {
      await SNMacConfig.setFactory(factory);
      _logState?.info('å·¥å‚è®¾ç½®ä¸º: $factory');
      notifyListeners();
    } catch (e) {
      _logState?.error('è®¾ç½®å·¥å‚å¤±è´¥: $e');
    }
  }

  /// è®¾ç½®äº§çº¿
  Future<void> setProductionLine(int line) async {
    try {
      await SNMacConfig.setProductionLine(line);
      _logState?.info('äº§çº¿è®¾ç½®ä¸º: $line');
      notifyListeners();
    } catch (e) {
      _logState?.error('è®¾ç½®äº§çº¿å¤±è´¥: $e');
    }
  }

  /// è·å–SN/MACç»Ÿè®¡ä¿¡æ¯
  Map<String, dynamic> getSNMacStatistics() {
    return SNMacConfig.getStatistics();
  }

  /// è·å–å½“å‰SN/MACé…ç½®
  Map<String, dynamic> getSNMacConfig() {
    return SNMacConfig.getCurrentConfig();
  }

  /// åœæ­¢å½“å‰æµ‹è¯•
  void stopTest() {
    if (_isRunningTest) {
      _shouldStopTest = true;
      _logState?.warning('âš ï¸  ç”¨æˆ·è¯·æ±‚åœæ­¢æµ‹è¯•...');
      notifyListeners();
    }
  }

  /// æ£€æŸ¥æ˜¯å¦åº”è¯¥åœæ­¢æµ‹è¯•
  bool get shouldStopTest => _shouldStopTest;

  /// é‡è¯•å•ä¸ªWiFiæµ‹è¯•æ­¥éª¤
  Future<bool> retryWiFiStep(int stepIndex) async {
    if (stepIndex < 0 || stepIndex >= _wifiTestSteps.length) {
      return false;
    }

    final currentStep = _wifiTestSteps[stepIndex];
    _logState?.info('ğŸ”„ æ‰‹åŠ¨é‡è¯•: ${currentStep.name}');
    
    // é‡ç½®æ­¥éª¤çŠ¶æ€
    _wifiTestSteps[stepIndex] = currentStep.copyWith(
      status: WiFiStepStatus.waiting,
      currentRetry: 0,
      errorMessage: null,
    );
    notifyListeners();

    return await _executeWiFiStepWithRetry(stepIndex);
  }

  /// æ‰§è¡ŒWiFiæ­¥éª¤ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
  Future<bool> _executeWiFiStepWithRetry(int stepIndex) async {
    final maxRetries = _wifiTestSteps[stepIndex].maxRetries;
    
    for (int retry = 0; retry <= maxRetries; retry++) {
      // æ¯æ¬¡å¾ªç¯éƒ½è·å–æœ€æ–°çš„æ­¥éª¤å¯¹è±¡
      final currentStep = _wifiTestSteps[stepIndex];
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦åœæ­¢æµ‹è¯•
      if (_shouldStopTest) {
        _wifiTestSteps[stepIndex] = currentStep.copyWith(
          status: WiFiStepStatus.failed,
          errorMessage: 'ç”¨æˆ·åœæ­¢æµ‹è¯•',
        );
        notifyListeners();
        return false;
      }

      // æ›´æ–°æ­¥éª¤çŠ¶æ€
      _wifiTestSteps[stepIndex] = currentStep.copyWith(
        status: WiFiStepStatus.testing,
        currentRetry: retry,
      );
      notifyListeners();

      if (retry > 0) {
        _logState?.warning('ğŸ”„ é‡è¯•ç¬¬ $retry æ¬¡: ${currentStep.name}', type: LogType.debug);
        await Future.delayed(const Duration(milliseconds: 500));
      }

      try {
        final success = await _executeWiFiStepSingle(stepIndex);
        if (success) {
          final successStep = _wifiTestSteps[stepIndex];
          _wifiTestSteps[stepIndex] = successStep.copyWith(
            status: WiFiStepStatus.success,
            currentRetry: retry,
          );
          notifyListeners();
          return true;
        }
      } catch (e) {
        _logState?.error('WiFiæ­¥éª¤æ‰§è¡Œå¼‚å¸¸: $e', type: LogType.debug);
      }

      // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡é‡è¯•ï¼Œç»§ç»­
      if (retry < maxRetries) {
        await Future.delayed(const Duration(milliseconds: 1000));
      }
    }

    // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
    final finalStep = _wifiTestSteps[stepIndex];
    _wifiTestSteps[stepIndex] = finalStep.copyWith(
      status: WiFiStepStatus.failed,
      errorMessage: 'é‡è¯• $maxRetries æ¬¡åä»ç„¶å¤±è´¥',
    );
    notifyListeners();
    return false;
  }

  /// Connect to serial port
  Future<bool> connectToPort(String portName) async {
    _logState?.info('æ­£åœ¨è¿æ¥ä¸²å£: $portName');

    // ç›´æ¥ä½¿ç”¨ 2000000 æ³¢ç‰¹ç‡è¿æ¥ï¼ˆä¸ä½¿ç”¨åŒçº¿UARTåˆå§‹åŒ–ï¼Œä¸ WindTerm ä¸€è‡´ï¼‰
    _logState?.info('ä½¿ç”¨ 2000000 æ³¢ç‰¹ç‡è¿æ¥ï¼ˆä¸ WindTerm é…ç½®ä¸€è‡´ï¼‰');
    bool success = await _serialService.connect(
      portName,
      baudRate: 2000000,
      useDualLineUartInit: false, // ä¸å‘é€åˆå§‹åŒ–æ•°æ®ï¼Œåªç›‘å¬
    );

    if (success) {
      _selectedPort = portName;
      _logState?.success('ä¸²å£è¿æ¥æˆåŠŸ: $portName');

      // è¿æ¥æˆåŠŸååªç›‘å¬ï¼Œä¸å‘é€ä»»ä½•å‘½ä»¤
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      _logState?.info('å¼€å§‹ç›‘å¬ä¸²å£æ•°æ®ï¼ˆä¸å‘é€ä»»ä½•å‘½ä»¤ï¼‰');
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      // await _serialService.sendExitSleepMode(retries: 5);

      // åˆ›å»ºæµ‹è¯•ç»„
      _currentTestGroup = TestGroup(
        name: portName,
        items: [],
      );
      notifyListeners();
    } else {
      _logState?.error('ä¸²å£è¿æ¥å¤±è´¥: $portName');
      _logState?.error('è¯·æ£€æŸ¥:');
      _logState?.error('  1. æ˜¯å¦æœ‰å…¶ä»–ç¨‹åºï¼ˆå¦‚WindTermï¼‰æ­£åœ¨ä½¿ç”¨è¯¥ä¸²å£');
      _logState?.error('  2. è¿è¡Œ: lsof | grep $portName æŸ¥çœ‹å ç”¨è¿›ç¨‹');
      _logState?.error('  3. è¿è¡Œ: sudo chmod 666 $portName ä¿®æ”¹æƒé™');
    }
    return success;
  }

  /// Disconnect from serial port
  Future<void> disconnect() async {
    _logState?.info('æ­£åœ¨æ–­å¼€ä¸²å£è¿æ¥');
    
    // å¦‚æœæ­£åœ¨è¿è¡Œæµ‹è¯•ï¼Œå…ˆåœæ­¢æµ‹è¯•
    if (_isRunningTest) {
      _logState?.warning('âš ï¸  æ£€æµ‹åˆ°æ­£åœ¨è¿è¡Œæµ‹è¯•ï¼Œè‡ªåŠ¨åœæ­¢...');
      stopTest();
    }
    
    await _serialService.disconnect();
    _selectedPort = null;
    _currentTestGroup = null; // æ–­å¼€è¿æ¥æ—¶æ¸…ç©ºæµ‹è¯•ç»„
    _logState?.info('ä¸²å£å·²æ–­å¼€');
    notifyListeners();
  }

  /// Update test item with status and error message
  void _updateTestItemWithStatus(
      int itemIndex, String result, Color backgroundColor, TestStatus status,
      {String? errorMessage}) {
    if (_currentTestGroup == null ||
        itemIndex >= _currentTestGroup!.items.length) return;

    final item = _currentTestGroup!.items[itemIndex];

    _currentTestGroup = TestGroup(
      name: _currentTestGroup!.name,
      items: List.from(_currentTestGroup!.items)
        ..[itemIndex] = TestItem(
          name: item.name,
          method: item.method,
          result: result,
          backgroundColor: backgroundColor,
          status: status,
          errorMessage: errorMessage,
        ),
    );

    notifyListeners();
  }

  /// Retry a specific test
  Future<void> retryTest(int itemIndex) async {
    if (!_serialService.isConnected) {
      debugPrint('Please connect to a serial port first');
      return;
    }

    if (_isRunningTest) {
      debugPrint('Test already running');
      return;
    }

    _isRunningTest = true;
    notifyListeners();

    // Re-run tests starting from the failed item
    await _runProductionTestSequence();

    _isRunningTest = false;
    notifyListeners();
  }

  /// Run production test sequence
  Future<void> _runProductionTestSequence() async {
    if (!_serialService.isConnected) {
      debugPrint('Serial port not connected');
      _logState?.error('ä¸²å£æœªè¿æ¥ï¼Œæ— æ³•å¼€å§‹æµ‹è¯•');
      return;
    }

    if (_currentTestGroup == null) {
      debugPrint('No test group available');
      _logState?.error('æ²¡æœ‰å¯ç”¨çš„æµ‹è¯•ç»„');
      return;
    }

    try {
      // æµ‹è¯•å¼€å§‹å‰å…ˆç¡®ä¿å”¤é†’è®¾å¤‡æˆåŠŸ
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      _logState?.info('å‡†å¤‡å¼€å§‹äº§æµ‹åºåˆ—');
      _logState?.info('æ­£åœ¨å”¤é†’è®¾å¤‡...');
      
      // ç¬¬ä¸€æ¬¡å”¤é†’å¿…é¡»æˆåŠŸ
      bool wakeupSuccess = false;
      for (int i = 0; i < 10; i++) {
        _logState?.info('ğŸ”” å°è¯•å”¤é†’è®¾å¤‡ (${i + 1}/10)...');
        bool result = await _serialService.sendExitSleepMode(retries: 1);
        if (result) {
          wakeupSuccess = true;
          _logState?.success('âœ… è®¾å¤‡å”¤é†’æˆåŠŸï¼');
          break;
        }
        await Future.delayed(const Duration(milliseconds: 500));
      }
      
      if (!wakeupSuccess) {
        _logState?.error('âŒ è®¾å¤‡å”¤é†’å¤±è´¥ï¼Œæ— æ³•å¼€å§‹æµ‹è¯•');
        return;
      }
      
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

      // Test sequence based on manual test buttons (ä¸æ‰‹åŠ¨æµ‹è¯•æŒ‰é’®å¯¹é½)
      final testSequence = [
        {
          'name': 'äº§æµ‹å¼€å§‹',
          'cmd': ProductionTestCommands.createStartTestCommand(),
          'cmdCode': ProductionTestCommands.cmdStartTest
        },
        {
          'name': 'è·å–è®¾å¤‡ç”µå‹',
          'cmd': ProductionTestCommands.createGetVoltageCommand(),
          'cmdCode': ProductionTestCommands.cmdGetVoltage
        },
        {
          'name': 'è·å–è®¾å¤‡ç”µé‡',
          'cmd': ProductionTestCommands.createGetCurrentCommand(),
          'cmdCode': ProductionTestCommands.cmdGetCurrent
        },
        {
          'name': 'è·å–å……ç”µçŠ¶æ€',
          'cmd': ProductionTestCommands.createGetChargeStatusCommand(),
          'cmdCode': ProductionTestCommands.cmdGetChargeStatus
        },
        {
          'name': 'æ§åˆ¶WiFi',
          'customAction': 'testWiFi'
        },
        {
          'name': 'LEDç¯(å¤–ä¾§)å¼€å¯',
          'cmd': ProductionTestCommands.createControlLEDCommand(
              ProductionTestCommands.ledOuter, ProductionTestCommands.ledOn),
          'cmdCode': ProductionTestCommands.cmdControlLED
        },
        {
          'name': 'LEDç¯(å¤–ä¾§)å…³é—­',
          'cmd': ProductionTestCommands.createControlLEDCommand(
              ProductionTestCommands.ledOuter, ProductionTestCommands.ledOff),
          'cmdCode': ProductionTestCommands.cmdControlLED
        },
        {
          'name': 'LEDç¯(å†…ä¾§)å¼€å¯',
          'cmd': ProductionTestCommands.createControlLEDCommand(
              ProductionTestCommands.ledInner, ProductionTestCommands.ledOn),
          'cmdCode': ProductionTestCommands.cmdControlLED
        },
        {
          'name': 'LEDç¯(å†…ä¾§)å…³é—­',
          'cmd': ProductionTestCommands.createControlLEDCommand(
              ProductionTestCommands.ledInner, ProductionTestCommands.ledOff),
          'cmdCode': ProductionTestCommands.cmdControlLED
        },
        {
          'name': 'SPK0',
          'cmd': ProductionTestCommands.createControlSPKCommand(
              ProductionTestCommands.spk0),
          'cmdCode': ProductionTestCommands.cmdControlSPK
        },
        {
          'name': 'SPK1',
          'cmd': ProductionTestCommands.createControlSPKCommand(
              ProductionTestCommands.spk1),
          'cmdCode': ProductionTestCommands.cmdControlSPK
        },
        {
          'name': 'Touchå·¦ä¾§',
          'cmd': null,
          'cmdCode': ProductionTestCommands.cmdTouch,
          'customAction': 'testTouchLeft'
        },
        {
          'name': 'Touchå³ä¾§',
          'cmd': null,
          'cmdCode': ProductionTestCommands.cmdTouch,
          'customAction': 'testTouchRight'
        },
        {
          'name': 'MIC0å¼€å¯',
          'cmd': ProductionTestCommands.createControlMICCommand(
              ProductionTestCommands.mic0,
              ProductionTestCommands.micControlOpen),
          'cmdCode': ProductionTestCommands.cmdControlMIC
        },
        {
          'name': 'MIC1å¼€å¯',
          'cmd': ProductionTestCommands.createControlMICCommand(
              ProductionTestCommands.mic1,
              ProductionTestCommands.micControlOpen),
          'cmdCode': ProductionTestCommands.cmdControlMIC
        },
        {
          'name': 'MIC2å¼€å¯',
          'cmd': ProductionTestCommands.createControlMICCommand(
              ProductionTestCommands.mic2,
              ProductionTestCommands.micControlOpen),
          'cmdCode': ProductionTestCommands.cmdControlMIC
        },
        {
          'name': 'RTCè®¾ç½®æ—¶é—´',
          'cmd': null,
          'cmdCode': ProductionTestCommands.cmdRTC,
          'customAction': 'setRTC'
        },
        {
          'name': 'RTCè·å–æ—¶é—´',
          'cmd': ProductionTestCommands.createRTCCommand(
              ProductionTestCommands.rtcOptGetTime),
          'cmdCode': ProductionTestCommands.cmdRTC
        },
        {
          'name': 'å…‰æ•ä¼ æ„Ÿå™¨',
          'cmd': ProductionTestCommands.createLightSensorCommand(),
          'cmdCode': ProductionTestCommands.cmdLightSensor
        },
        {
          'name': 'IMUæ•°æ®',
          'customAction': 'testIMU'
        },
        {
          'name': 'äº§æµ‹ç»“æŸ',
          'cmd': ProductionTestCommands.createEndTestCommand(),
          'cmdCode': ProductionTestCommands.cmdEndTest
        },
      ];

      // Initialize test items for this group
      _currentTestGroup = TestGroup(
        name: _currentTestGroup!.name,
        items: testSequence
            .map((test) => TestItem(
                  name: test['name'] as String,
                  method: 'Auto',
                  result: 'Waiting',
                  backgroundColor: Colors.grey[300]!,
                ))
            .toList(),
      );
      notifyListeners();

      // Run each test with retry mechanism
      for (int i = 0; i < testSequence.length; i++) {
        // æ£€æŸ¥æ˜¯å¦éœ€è¦åœæ­¢æµ‹è¯•
        if (_shouldStopTest) {
          _logState?.warning('ğŸ›‘ æµ‹è¯•å·²è¢«ç”¨æˆ·åœæ­¢');
          _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
          break;
        }

        final test = testSequence[i];
        final testName = test['name'] as String;
        final command = test['cmd'] as dynamic;
        final cmdCode = test['cmdCode'] as int;
        final customAction = test['customAction'] as String?;

        debugPrint('Running test: $testName');

        // æ¯ä¸ªæµ‹è¯•é¡¹ç›®å¼€å§‹å‰å”¤é†’ä¸€æ¬¡ï¼ˆåœ¨é‡è¯•å¾ªç¯å¤–ï¼‰
        try {
          _logState?.debug('ğŸ”” [$testName] å”¤é†’è®¾å¤‡...', type: LogType.debug);
          bool wakeupResult = await _serialService.sendExitSleepMode(retries: 1);
          if (wakeupResult) {
            _logState?.debug('âœ… [$testName] å”¤é†’å®Œæˆ', type: LogType.debug);
          }
          // ç­‰å¾…300msï¼Œç¡®ä¿å”¤é†’å“åº”å®Œå…¨å¤„ç†
          await Future.delayed(const Duration(milliseconds: 300));
        } catch (e) {
          _logState?.warning('âš ï¸  [$testName] å”¤é†’å¤±è´¥: $e', type: LogType.debug);
          await Future.delayed(const Duration(milliseconds: 300));
        }

        bool testPassed = false;
        int retryCount = 0;
        const maxRetries = 10;

        // Retry loop for failed tests
        while (!testPassed && retryCount <= maxRetries) {
          // åœ¨é‡è¯•å¾ªç¯ä¸­ä¹Ÿæ£€æŸ¥åœæ­¢æ ‡å¿—
          if (_shouldStopTest) {
            _logState?.warning('ğŸ›‘ æµ‹è¯•å·²è¢«ç”¨æˆ·åœæ­¢');
            break;
          }

          if (retryCount > 0) {
            _logState?.warning('ğŸ”„ é‡è¯•ç¬¬ $retryCount æ¬¡: $testName',
                type: LogType.debug);
            // é‡è¯•æ—¶ç­‰å¾…ä¸€ä¸‹ï¼Œä½†ä¸å†å‘é€å”¤é†’å‘½ä»¤
            await Future.delayed(const Duration(milliseconds: 500));
          }
          
          // Update status to testing
          final statusText = retryCount > 0
              ? 'Testing (é‡è¯• $retryCount/$maxRetries)'
              : 'Testing';
          _updateTestItemWithStatus(
              i, statusText, const Color(0xFFFFFF00), TestStatus.testing);

          Map<String, dynamic>? response;

          // Handle custom actions or regular commands
          if (customAction != null) {
            switch (customAction) {
              case 'setRTC':
                final success = await setRTCTime();
                response = success 
                  ? {'success': true}
                  : {'error': 'RTCè®¾ç½®æ—¶é—´å¤±è´¥ï¼Œè¯·æ£€æŸ¥è®¾å¤‡è¿æ¥æˆ–æ—¥å¿—'};
                break;
              case 'testTouchLeft':
                await testTouchLeft();
                response = {
                  'success': true
                }; // Assume success for custom actions
                break;
              case 'testTouchRight':
                await testTouchRight();
                response = {
                  'success': true
                }; // Assume success for custom actions
                break;
              case 'testWiFi':
                final success = await testWiFi();
                response = success 
                  ? {'success': true}
                  : {'error': 'WiFiæµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥è®¾å¤‡è¿æ¥æˆ–é…ç½®'};
                break;
              case 'testIMU':
                final success = await testIMU();
                response = success 
                  ? {'success': true}
                  : {'error': 'IMUæµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥è®¾å¤‡è¿æ¥'};
                break;
              default:
                response = {'error': 'Unknown custom action: $customAction'};
            }
          } else if (command != null) {
            // æ˜¾ç¤ºå‘é€çš„å‘½ä»¤ï¼ŒåŒ…å«æµ‹è¯•é¡¹ç›®åç§°
            final commandHex = command.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
            _logState?.info('ğŸ“¤ [$testName] å‘é€: [$commandHex]', type: LogType.debug);
            
            // Send regular command and wait for response
            response = await _serialService.sendCommandAndWaitResponse(
              command,
              timeout: TestConfig.defaultTimeout,
              moduleId: ProductionTestCommands.moduleId,
              messageId: ProductionTestCommands.messageId,
            );
            
            // æ˜¾ç¤ºæ¥æ”¶åˆ°çš„payload
            if (response != null && response.containsKey('payload')) {
              final payload = response['payload'] as Uint8List;
              final payloadHex = payload.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
              _logState?.info('ğŸ“¥ [$testName] æ¥æ”¶: [$payloadHex] (${payload.length} bytes)', type: LogType.debug);
              
              // æ£€æŸ¥payloadé•¿åº¦æ˜¯å¦åˆç†
              if (payload.isEmpty) {
                _logState?.warning('âš ï¸  [$testName] Payloadä¸ºç©ºï¼', type: LogType.debug);
              }
            }
          } else {
            response = {'error': 'No command or custom action specified'};
          }

          if (response == null) {
            debugPrint('Test $testName: Timeout (attempt ${retryCount + 1})');
            if (retryCount >= maxRetries) {
              _updateTestItemWithStatus(i, 'Timeout (é‡è¯• $maxRetries æ¬¡åå¤±è´¥)',
                  const Color(0xFFFF6347), TestStatus.timeout,
                  errorMessage: 'è®¾å¤‡å“åº”è¶…æ—¶ï¼Œå·²é‡è¯• $maxRetries æ¬¡');
              break; // Exit retry loop, continue to next test
            }
          } else if (response.containsKey('error')) {
            debugPrint(
                'Test $testName: Error - ${response['error']} (attempt ${retryCount + 1})');
            if (retryCount >= maxRetries) {
              _updateTestItemWithStatus(i, 'Error (é‡è¯• $maxRetries æ¬¡åå¤±è´¥)',
                  const Color(0xFFFF6347), TestStatus.error,
                  errorMessage: '${response['error']}ï¼Œå·²é‡è¯• $maxRetries æ¬¡');
              break; // Exit retry loop, continue to next test
            }
          } else {
            // Parse response based on command type
            String result = 'Pass';
            TestStatus status = TestStatus.pass;
            String? errorMsg;

            // Check if this is a custom action response (no payload to parse)
            if (response.containsKey('success') && response['success'] == true) {
              // Custom action completed successfully
              result = 'Pass';
              status = TestStatus.pass;
            } else {
              // Regular command response - parse payload
              try {
                switch (cmdCode) {
                case ProductionTestCommands.cmdGetVoltage:
                  final voltage = ProductionTestCommands.parseVoltageResponse(
                      response['payload']);
                  if (voltage != null) {
                    result = 'Pass (${voltage}mV)';
                    status = TestStatus.pass;
                  } else {
                    _logState?.error('âŒ è§£æå¤±è´¥: æ— æ³•è§£æç”µå‹æ•°æ®', type: LogType.debug);
                    result = 'Fail';
                    status = TestStatus.fail;
                    errorMsg = 'æ— æ³•è§£æç”µå‹æ•°æ®';
                  }
                  break;

                case ProductionTestCommands.cmdGetCurrent:
                  final current = ProductionTestCommands.parseCurrentResponse(
                      response['payload']);
                  result = current != null ? 'Pass ($current%)' : 'Fail';
                  status = current != null ? TestStatus.pass : TestStatus.fail;
                  if (current == null) errorMsg = 'æ— æ³•è§£æç”µé‡æ•°æ®';
                  break;

                case ProductionTestCommands.cmdGetChargeStatus:
                  final chargeStatus =
                      ProductionTestCommands.parseChargeStatusResponse(
                          response['payload']);
                  if (chargeStatus != null) {
                    result =
                        'Pass (${ProductionTestCommands.getChargeModeName(chargeStatus['mode']!)})';
                    status = TestStatus.pass;
                  } else {
                    result = 'Fail';
                    status = TestStatus.fail;
                    errorMsg = 'æ— æ³•è§£æå……ç”µçŠ¶æ€';
                  }
                  break;

                case ProductionTestCommands.cmdControlWifi:
                  // æ³¨æ„ï¼šè¿™ä¸ªcaseå¯èƒ½ä¸ä¼šè¢«ä½¿ç”¨ï¼Œå› ä¸ºWiFiæµ‹è¯•é€šè¿‡customActionæ‰§è¡Œ
                  // ä¼ å…¥0x00ä½œä¸ºé»˜è®¤optå€¼
                  final wifiResult = ProductionTestCommands.parseWifiResponse(
                      response['payload'], 0x00);
                  if (wifiResult != null && wifiResult['success'] == true) {
                    String details = wifiResult['optName'] ?? '';
                    if (wifiResult.containsKey('rssi')) {
                      details += ' (RSSI: ${wifiResult['rssi']}dBm)';
                    } else if (wifiResult.containsKey('mac')) {
                      details += ' (MAC: ${wifiResult['mac']})';
                    }
                    result = 'Pass ($details)';
                    status = TestStatus.pass;
                  } else {
                    result = 'Fail';
                    status = TestStatus.fail;
                    errorMsg = wifiResult?['error'] ?? 'æ— æ³•è§£æWiFiå“åº”';
                  }
                  break;

                case ProductionTestCommands.cmdTouch:
                  final touchResult = ProductionTestCommands.parseTouchResponse(
                      response['payload']);
                  if (touchResult != null && touchResult['success'] == true) {
                    final cdcValue = touchResult['cdcValue'];
                    result = 'Pass (CDC: $cdcValue)';
                    status = TestStatus.pass;
                  } else {
                    result = 'Fail';
                    status = TestStatus.fail;
                    errorMsg = touchResult?['error'] ?? 'æ— æ³•è§£æTouchæ•°æ®';
                  }
                  break;

                case ProductionTestCommands.cmdRTC:
                  final timestamp = ProductionTestCommands.parseRTCResponse(
                      response['payload']);
                  if (timestamp != null) {
                    final dateTime =
                        DateTime.fromMillisecondsSinceEpoch(timestamp);
                    result = 'Pass (${dateTime.toString()})';
                    status = TestStatus.pass;
                  } else {
                    result = 'Fail';
                    status = TestStatus.fail;
                    errorMsg = 'æ— æ³•è§£æRTCæ—¶é—´';
                  }
                  break;

                case ProductionTestCommands.cmdLightSensor:
                  final lightValue =
                      ProductionTestCommands.parseLightSensorResponse(
                          response['payload']);
                  result = lightValue != null
                      ? 'Pass (${lightValue.toStringAsFixed(2)} lux)'
                      : 'Fail';
                  status =
                      lightValue != null ? TestStatus.pass : TestStatus.fail;
                  if (lightValue == null) errorMsg = 'æ— æ³•è§£æå…‰æ•æ•°æ®';
                  break;

                case ProductionTestCommands.cmdIMU:
                  final imuData = ProductionTestCommands.parseIMUResponse(
                      response['payload']);
                  if (imuData != null) {
                    result =
                        'Pass (Accel: ${imuData['accel_x']?.toStringAsFixed(2)}, ${imuData['accel_y']?.toStringAsFixed(2)}, ${imuData['accel_z']?.toStringAsFixed(2)})';
                    status = TestStatus.pass;
                  } else {
                    result = 'Fail';
                    status = TestStatus.fail;
                    errorMsg = 'æ— æ³•è§£æIMUæ•°æ®';
                  }
                  break;

                default:
                  // For other commands, just check if we got a response
                  result = 'Pass';
                  status = TestStatus.pass;
                  break;
                }
              } catch (e) {
                result = 'Error';
                status = TestStatus.error;
                errorMsg = 'è§£æå“åº”æ—¶å‡ºé”™: $e';
              }
            }

            debugPrint('Test $testName: $result (attempt ${retryCount + 1})');

            if (status == TestStatus.pass) {
              // Test passed, exit retry loop
              testPassed = true;
              final finalResult =
                  retryCount > 0 ? '$result (é‡è¯• $retryCount æ¬¡åæˆåŠŸ)' : result;
              _updateTestItemWithStatus(
                i,
                finalResult,
                const Color(0xFF4CAF50),
                status,
                errorMessage: errorMsg,
              );
            } else {
              // Test failed, check if we should retry
              if (retryCount >= maxRetries) {
                final finalResult = '$result (é‡è¯• $maxRetries æ¬¡åå¤±è´¥)';
                _updateTestItemWithStatus(
                  i,
                  finalResult,
                  const Color(0xFFFF6347),
                  status,
                  errorMessage: errorMsg != null
                      ? '$errorMsgï¼Œå·²é‡è¯• $maxRetries æ¬¡'
                      : 'å·²é‡è¯• $maxRetries æ¬¡',
                );
                break; // Exit retry loop, continue to next test
              }
            }
          }

          retryCount++;

          // Add delay before retry
          if (!testPassed && retryCount <= maxRetries) {
            await Future.delayed(const Duration(
                milliseconds: 1000)); // 1 second delay before retry
          }
        }

        // If we exit the retry loop without success, skip to next test
        if (!testPassed) {
          _logState?.error('âŒ [$testName] é‡è¯• $maxRetries æ¬¡åä»ç„¶å¤±è´¥ï¼Œè·³è¿‡è¯¥é¡¹æµ‹è¯•', type: LogType.debug);
          // continue to next test instead of breaking
          continue;
        }
      }
    } catch (e) {
      debugPrint('Test error: $e');
    }
  }

  void startTest() async {
    if (_isRunningTest) {
      debugPrint('Test already running');
      return;
    }

    if (!_serialService.isConnected) {
      debugPrint('Please connect to a serial port first');
      return;
    }

    if (_currentTestGroup == null) {
      debugPrint('No test group available');
      return;
    }

    _isRunningTest = true;
    _shouldStopTest = false; // é‡ç½®åœæ­¢æ ‡å¿—
    notifyListeners();

    debugPrint('Starting test for: ${_currentTestGroup!.name}');
    await _runProductionTestSequence();

    _isRunningTest = false;
    _shouldStopTest = false; // æµ‹è¯•ç»“æŸæ—¶é‡ç½®åœæ­¢æ ‡å¿—
    notifyListeners();
  }

  /// Set RTC time to current UTC time
  /// Returns true if successful, false otherwise
  Future<bool> setRTCTime() async {
    if (!_serialService.isConnected) {
      _logState?.error('[RTC] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return false;
    }

    try {
      // è·å–å½“å‰ UTC æ—¶é—´æˆ³ï¼ˆæ¯«ç§’çº§ï¼Œä½†æ¯«ç§’ä½ä¸º0ï¼Œç²¾ç¡®åˆ°ç§’ï¼‰
      final now = DateTime.now().toUtc();
      final timestampMs = (now.millisecondsSinceEpoch ~/ 1000) * 1000; // æ¯«ç§’ä½è®¾ä¸º0

      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ• RTC è®¾ç½®æ—¶é—´', type: LogType.debug);
      _logState?.info('ğŸ“… UTC æ—¶é—´: ${now.toIso8601String()}',
          type: LogType.debug);
      _logState?.info('ğŸ“¤ æ—¶é—´æˆ³: $timestampMs ms (${timestampMs ~/ 1000} s)',
          type: LogType.debug);
      _logState?.info('ğŸ“¤ Opt: 0x00 (è®¾ç½®æ—¶é—´)', type: LogType.debug);
      _logState?.info('â±ï¸  å‘é€æ—¶é—´: ${DateTime.now().toString()}',
          type: LogType.debug);

      final command = ProductionTestCommands.createRTCCommand(
        ProductionTestCommands.rtcOptSetTime,
        timestamp: timestampMs,
      );

      // æ˜¾ç¤ºå®Œæ•´æŒ‡ä»¤æ•°æ®
      final commandHex = command
          .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
          .join(' ');
      _logState?.info('ğŸ“¦ å‘é€æŒ‡ä»¤: [$commandHex] (${command.length} bytes)',
          type: LogType.debug);

      // è¯¦ç»†è§£ææŒ‡ä»¤ç»“æ„
      if (command.length == 10) {
        _logState?.info('ğŸ“‹ æŒ‡ä»¤ç»“æ„:', type: LogType.debug);
        _logState?.info(
            '   - CMD: 0x${command[0].toRadixString(16).toUpperCase().padLeft(2, '0')} (RTCå‘½ä»¤)',
            type: LogType.debug);
        _logState?.info(
            '   - OPT: 0x${command[1].toRadixString(16).toUpperCase().padLeft(2, '0')} (è®¾ç½®æ—¶é—´)',
            type: LogType.debug);

        // è§£ææ—¶é—´æˆ³å­—èŠ‚
        final timestampBytes = command.sublist(2);
        final timestampHex = timestampBytes
            .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
            .join(' ');
        _logState?.info('   - æ—¶é—´æˆ³: [$timestampHex] (8 bytes, little endian)',
            type: LogType.debug);
      }

      final response = await _serialService.sendCommandAndWaitResponse(
        command,
        timeout: TestConfig.defaultTimeout,
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (response != null && !response.containsKey('error')) {
        _logState?.success('âœ… RTC æ—¶é—´è®¾ç½®æˆåŠŸ', type: LogType.debug);

        // æ˜¾ç¤ºå“åº”æ•°æ®
        if (response.containsKey('payload') && response['payload'] != null) {
          final payload = response['payload'] as Uint8List;
          final payloadHex = payload
              .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
              .join(' ');
          _logState?.info('ğŸ“¥ å“åº”æ•°æ®: [$payloadHex] (${payload.length} bytes)',
              type: LogType.debug);
          
          // æ£€æŸ¥å“åº”æ•°æ®æ˜¯å¦æœ‰æ•ˆï¼ˆè‡³å°‘åŒ…å«å‘½ä»¤å­—ï¼‰
          if (payload.isNotEmpty && payload[0] == ProductionTestCommands.cmdRTC) {
            _logState?.info('ğŸ“Œ RTC è®¾ç½®æ—¶é—´æˆåŠŸï¼Œæ”¶åˆ°æœ‰æ•ˆå“åº”', type: LogType.debug);
            _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
            return true;
          }
        }
        
        _logState?.warning('âš ï¸  RTC è®¾ç½®æ—¶é—´å“åº”æ•°æ®ä¸å®Œæ•´', type: LogType.debug);
      } else {
        _logState?.error('âŒ RTC æ—¶é—´è®¾ç½®å¤±è´¥: ${response?['error'] ?? 'æ— å“åº”'}',
            type: LogType.debug);
      }

      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      return false;
    } catch (e) {
      _logState?.error('RTC è®¾ç½®æ—¶é—´å¼‚å¸¸: $e', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      return false;
    }
  }

  /// Get RTC time from device
  Future<void> getRTCTime() async {
    if (!_serialService.isConnected) {
      _logState?.error('[RTC] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return;
    }

    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ• RTC è·å–æ—¶é—´', type: LogType.debug);
      _logState?.info('ğŸ“¤ Opt: 0x01 (è·å–æ—¶é—´)', type: LogType.debug);
      _logState?.info('â±ï¸  å‘é€æ—¶é—´: ${DateTime.now().toString()}',
          type: LogType.debug);

      final command = ProductionTestCommands.createRTCCommand(
        ProductionTestCommands.rtcOptGetTime,
      );

      // æ˜¾ç¤ºå®Œæ•´æŒ‡ä»¤æ•°æ®
      final commandHex = command
          .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
          .join(' ');
      _logState?.info('ğŸ“¦ å‘é€æŒ‡ä»¤: [$commandHex] (${command.length} bytes)',
          type: LogType.debug);

      // è¯¦ç»†è§£ææŒ‡ä»¤ç»“æ„
      if (command.length == 2) {
        _logState?.info('ğŸ“‹ æŒ‡ä»¤ç»“æ„:', type: LogType.debug);
        _logState?.info(
            '   - CMD: 0x${command[0].toRadixString(16).toUpperCase().padLeft(2, '0')} (RTCå‘½ä»¤)',
            type: LogType.debug);
        _logState?.info(
            '   - OPT: 0x${command[1].toRadixString(16).toUpperCase().padLeft(2, '0')} (è·å–æ—¶é—´)',
            type: LogType.debug);
      }

      final response = await _serialService.sendCommandAndWaitResponse(
        command,
        timeout: TestConfig.defaultTimeout,
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (response != null && !response.containsKey('error')) {
        _logState?.success('âœ… RTC æ—¶é—´è·å–æˆåŠŸ', type: LogType.debug);

        // æ˜¾ç¤ºå®Œæ•´å“åº”ä¿¡æ¯ç”¨äºè°ƒè¯•
        _logState?.info('ğŸ“Š å®Œæ•´å“åº”ä¿¡æ¯:', type: LogType.debug);
        response.forEach((key, value) {
          if (key == 'payload' && value is Uint8List) {
            final payloadHex = (value as Uint8List)
                .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
                .join(' ');
            _logState?.info(
                '   - $key: [$payloadHex] (${(value as Uint8List).length} bytes)',
                type: LogType.debug);
          } else {
            _logState?.info('   - $key: $value', type: LogType.debug);
          }
        });

        // æ˜¾ç¤ºå“åº”æ•°æ®å¹¶è§£ææ—¶é—´æˆ³
        if (response.containsKey('payload') && response['payload'] != null) {
          final payload = response['payload'] as Uint8List;
          final payloadHex = payload
              .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
              .join(' ');
          _logState?.info('ğŸ“¥ å“åº”æ•°æ®: [$payloadHex] (${payload.length} bytes)',
              type: LogType.debug);

          // è¯¦ç»†è§£æå“åº”ç»“æ„
          _logState?.info('ğŸ“‹ å“åº”ç»“æ„:', type: LogType.debug);
          if (payload.length == 9) {
            _logState?.info('   - æ ¼å¼: [CMD] + 8å­—èŠ‚æ—¶é—´æˆ³ (little endian)',
                type: LogType.debug);
            _logState?.info('   - CMD: 0x${payload[0].toRadixString(16).toUpperCase().padLeft(2, '0')}', type: LogType.debug);
            _logState?.info('   - æ—¶é—´æˆ³: [$payloadHex]', type: LogType.debug);

            // ä½¿ç”¨ ProductionTestCommands çš„è§£ææ–¹æ³•
            final timestamp = ProductionTestCommands.parseRTCResponse(payload);
            if (timestamp != null) {
              final dateTime =
                  DateTime.fromMillisecondsSinceEpoch(timestamp, isUtc: true);

              _logState?.info(
                  'ğŸ“… è®¾å¤‡æ—¶é—´æˆ³: $timestamp ms (${timestamp ~/ 1000} s)',
                  type: LogType.debug);
              _logState?.info('ğŸ“… UTC æ—¶é—´: ${dateTime.toIso8601String()}',
                  type: LogType.debug);
              _logState?.info('ğŸ“… æœ¬åœ°æ—¶é—´: ${dateTime.toLocal().toString()}',
                  type: LogType.debug);
            } else {
              _logState?.warning('âš ï¸  æ— æ³•è§£æRTCæ—¶é—´æˆ³æ•°æ®', type: LogType.debug);
            }
          } else if (payload.length == 0) {
            _logState?.warning('âš ï¸  å“åº”payloadä¸ºç©ºï¼Œè®¾å¤‡å¯èƒ½æœªè¿”å›æ—¶é—´æˆ³æ•°æ®',
                type: LogType.debug);
            _logState?.info('   - å¯èƒ½åŸå› : è®¾å¤‡RTCæœªåˆå§‹åŒ–æˆ–å‘½ä»¤å¤„ç†å¼‚å¸¸', type: LogType.debug);
          } else {
            _logState?.warning(
                'âš ï¸  å“åº”é•¿åº¦å¼‚å¸¸: ${payload.length} bytes (æœŸæœ›: 9 bytes)',
                type: LogType.debug);
            _logState?.info('   - æ ¼å¼: éæ ‡å‡†é•¿åº¦', type: LogType.debug);

            // å°è¯•è§£æéæ ‡å‡†é•¿åº¦çš„å“åº”
            if (payload.length >= 9) {
              _logState?.info('   - å°è¯•è§£æ...', type: LogType.debug);
              final timestamp =
                  ProductionTestCommands.parseRTCResponse(payload);
              if (timestamp != null) {
                final dateTime =
                    DateTime.fromMillisecondsSinceEpoch(timestamp, isUtc: true);
                _logState?.info(
                    'ğŸ“… è®¾å¤‡æ—¶é—´æˆ³: $timestamp ms (${timestamp ~/ 1000} s)',
                    type: LogType.debug);
                _logState?.info('ğŸ“… UTC æ—¶é—´: ${dateTime.toIso8601String()}',
                    type: LogType.debug);
                _logState?.info('ğŸ“… æœ¬åœ°æ—¶é—´: ${dateTime.toLocal().toString()}',
                    type: LogType.debug);
              }
            }
          }
        } else {
          _logState?.error('âŒ å“åº”ä¸­æ²¡æœ‰payloadæ•°æ®', type: LogType.debug);
        }
      } else {
        _logState?.error('âŒ RTC æ—¶é—´è·å–å¤±è´¥: ${response?['error'] ?? 'æ— å“åº”'}',
            type: LogType.debug);
      }

      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
    } catch (e) {
      _logState?.error('RTC è·å–æ—¶é—´å¼‚å¸¸: $e', type: LogType.debug);
    }
  }

  /// Toggle LED state (on/off)
  Future<void> toggleLedState(int ledNumber) async {
    if (!_serialService.isConnected) {
      _logState?.error('[LED$ledNumber] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return;
    }

    // åˆ‡æ¢çŠ¶æ€
    final currentState = _ledStates[ledNumber] ?? false;
    final newState = !currentState;
    final state =
        newState ? ProductionTestCommands.ledOn : ProductionTestCommands.ledOff;
    final stateText = newState ? 'å¼€å¯' : 'å…³é—­';
    final ledName = ProductionTestCommands.getLEDName(ledNumber);

    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ’¡ $ledName æ§åˆ¶ - $stateText', type: LogType.debug);
      _logState?.info(
          'ğŸ“Š å½“å‰çŠ¶æ€: ${currentState ? "å·²å¼€å¯" : "å·²å…³é—­"} â†’ ç›®æ ‡çŠ¶æ€: ${newState ? "å·²å¼€å¯" : "å·²å…³é—­"}',
          type: LogType.debug);
      _logState?.info(
          'ğŸ“¤ LEDå·: 0x${ledNumber.toRadixString(16).toUpperCase().padLeft(2, '0')} ($ledNumber)',
          type: LogType.debug);
      _logState?.info(
          'ğŸ“¤ çŠ¶æ€å­—: 0x${state.toRadixString(16).toUpperCase().padLeft(2, '0')} (${state == ProductionTestCommands.ledOn ? "å¼€å¯" : "å…³é—­"})',
          type: LogType.debug);
      _logState?.info('â±ï¸  å‘é€æ—¶é—´: ${DateTime.now().toString()}',
          type: LogType.debug);

      final command =
          ProductionTestCommands.createControlLEDCommand(ledNumber, state);

      // æ˜¾ç¤ºå®Œæ•´æŒ‡ä»¤æ•°æ®
      final commandHex = command
          .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
          .join(' ');
      _logState?.info('ğŸ“¦ å‘é€æŒ‡ä»¤: [$commandHex] (${command.length} bytes)',
          type: LogType.debug);

      final response = await _serialService.sendCommandAndWaitResponse(
        command,
        timeout: TestConfig.defaultTimeout,
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (response != null && !response.containsKey('error')) {
        // æ›´æ–°çŠ¶æ€
        _ledStates[ledNumber] = newState;
        notifyListeners();
        _logState?.success(
            'âœ… $ledName ${stateText}æˆåŠŸ - å½“å‰çŠ¶æ€: ${newState ? "å·²å¼€å¯ ğŸ’¡" : "å·²å…³é—­ âš«"}',
            type: LogType.debug);

        // æ˜¾ç¤ºå“åº”æ•°æ®
        if (response.containsKey('payload') && response['payload'] != null) {
          final payload = response['payload'] as Uint8List;
          final payloadHex = payload
              .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
              .join(' ');
          _logState?.info('ğŸ“¥ å“åº”æ•°æ®: [$payloadHex] (${payload.length} bytes)',
              type: LogType.debug);
        }
      } else {
        _logState?.error(
            'âŒ $ledName ${stateText}å¤±è´¥: ${response?['error'] ?? 'æ— å“åº”'}',
            type: LogType.debug);
      }

      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
    } catch (e) {
      _logState?.error('$ledName ${stateText}å¼‚å¸¸: $e', type: LogType.debug);
    }
  }

  /// Toggle MIC state (open/close)
  Future<void> toggleMicState(int micNumber) async {
    if (!_serialService.isConnected) {
      _logState?.error('[MIC$micNumber] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return;
    }

    // åˆ‡æ¢çŠ¶æ€
    final currentState = _micStates[micNumber] ?? false;
    final newState = !currentState;
    final control = newState
        ? ProductionTestCommands.micControlOpen
        : ProductionTestCommands.micControlClose;
    final stateText = newState ? 'å¼€å¯' : 'å…³é—­';

    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ¤ MIC$micNumber æ§åˆ¶ - $stateText', type: LogType.debug);
      _logState?.info(
          'ğŸ“Š å½“å‰çŠ¶æ€: ${currentState ? "å·²å¼€å¯" : "å·²å…³é—­"} â†’ ç›®æ ‡çŠ¶æ€: ${newState ? "å·²å¼€å¯" : "å·²å…³é—­"}',
          type: LogType.debug);
      _logState?.info(
          'ğŸ“¤ MICå·: 0x${micNumber.toRadixString(16).toUpperCase().padLeft(2, '0')} ($micNumber)',
          type: LogType.debug);
      _logState?.info(
          'ğŸ“¤ æ§åˆ¶å­—: 0x${control.toRadixString(16).toUpperCase().padLeft(2, '0')} (${control == ProductionTestCommands.micControlOpen ? "æ‰“å¼€" : "å…³é—­"})',
          type: LogType.debug);
      _logState?.info('â±ï¸  å‘é€æ—¶é—´: ${DateTime.now().toString()}',
          type: LogType.debug);

      final command =
          ProductionTestCommands.createControlMICCommand(micNumber, control);

      // æ˜¾ç¤ºå®Œæ•´æŒ‡ä»¤æ•°æ®
      final commandHex = command
          .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
          .join(' ');
      _logState?.info('ğŸ“¦ å‘é€æŒ‡ä»¤: [$commandHex] (${command.length} bytes)',
          type: LogType.debug);

      final response = await _serialService.sendCommandAndWaitResponse(
        command,
        timeout: TestConfig.defaultTimeout,
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (response != null && !response.containsKey('error')) {
        // æ›´æ–°çŠ¶æ€
        _micStates[micNumber] = newState;
        notifyListeners();
        _logState?.success(
            'âœ… MIC$micNumber ${stateText}æˆåŠŸ - å½“å‰çŠ¶æ€: ${newState ? "å·²å¼€å¯ ğŸŸ¢" : "å·²å…³é—­ âš«"}',
            type: LogType.debug);

        // æ˜¾ç¤ºå“åº”æ•°æ®
        if (response.containsKey('payload') && response['payload'] != null) {
          final payload = response['payload'] as Uint8List;
          final payloadHex = payload
              .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
              .join(' ');
          _logState?.info('ğŸ“¥ å“åº”æ•°æ®: [$payloadHex] (${payload.length} bytes)',
              type: LogType.debug);
        }
      } else {
        _logState?.error(
            'âŒ MIC$micNumber ${stateText}å¤±è´¥: ${response?['error'] ?? 'æ— å“åº”'}',
            type: LogType.debug);
      }

      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
    } catch (e) {
      _logState?.error('MIC$micNumber ${stateText}å¼‚å¸¸: $e', type: LogType.debug);
    }
  }

  /// Run manual test for a single command (non-blocking, allows concurrent execution)
  Future<void> runManualTest(String testName, dynamic command,
      {int? moduleId, int? messageId}) async {
    if (!_serialService.isConnected) {
      debugPrint('Serial port not connected');
      _logState?.error('[$testName] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return;
    }

    // ä¸å†æ£€æŸ¥ _isRunningTestï¼Œå…è®¸å¹¶å‘æ‰§è¡Œå¤šä¸ªæ‰‹åŠ¨æµ‹è¯•

    try {
      debugPrint('Running manual test: $testName');
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ”§ æ‰‹åŠ¨æµ‹è¯•: $testName', type: LogType.debug);
      _logState?.info('â±ï¸  å‘é€æ—¶é—´: ${DateTime.now().toString()}',
          type: LogType.debug);

      // Send command and wait for response
      final response = await _serialService.sendCommandAndWaitResponse(
        command,
        timeout: TestConfig.defaultTimeout,
        moduleId: moduleId ?? ProductionTestCommands.moduleId,
        messageId: messageId ?? ProductionTestCommands.messageId,
      );

      if (response != null) {
        if (response.containsKey('error')) {
          debugPrint('âœ— $testName error: ${response['error']}');
          _logState?.error('âŒ $testName - é”™è¯¯: ${response['error']}',
              type: LogType.debug);
        } else {
          debugPrint('âœ“ $testName completed successfully');
          _logState?.success('âœ… $testName - æ‰§è¡ŒæˆåŠŸ', type: LogType.debug);

          // æ˜¾ç¤ºå“åº”æ•°æ®
          if (response.containsKey('payload') && response['payload'] != null) {
            final payload = response['payload'] as Uint8List;
            _logState?.info('ğŸ“¦ å“åº”æ•°æ® (${payload.length} bytes)',
                type: LogType.debug);
          }
        }
      } else {
        debugPrint('âœ— $testName timeout or failed');
        _logState?.warning('â±ï¸  $testName - è¶…æ—¶æˆ–æ— å“åº”', type: LogType.debug);
      }

      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
    } catch (e) {
      debugPrint('Error running manual test: $e');
      _logState?.error('âŒ $testName - å¼‚å¸¸: $e', type: LogType.debug);
    }
    // ä¸å†è®¾ç½® _isRunningTest = falseï¼Œå› ä¸ºä¸å†ä½¿ç”¨é˜»å¡æœºåˆ¶
  }

  /// å³TouchåŠè‡ªåŠ¨åŒ–æµ‹è¯•
  Future<void> testTouchRight() async {
    if (!_serialService.isConnected) {
      _logState?.error('[Touchå³ä¾§] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return;
    }

    _isRightTouchTesting = true;
    _showTouchDialog = true;
    _isLeftTouchDialog = false;
    _initializeRightTouchTestSteps();
    notifyListeners();

    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ‘† å³TouchåŠè‡ªåŠ¨åŒ–æµ‹è¯•å¼€å§‹', type: LogType.debug);
      _logState?.info('â±ï¸  å¼€å§‹æ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);

      // æŒ‰é¡ºåºæ‰§è¡Œæ‰€æœ‰æ­¥éª¤
      for (int stepIndex = 0; stepIndex < _rightTouchTestSteps.length; stepIndex++) {
        if (_shouldStopTest) break;
        
        final success = await _executeRightTouchStep(stepIndex);
        if (!success) {
          _logState?.error('âŒ å³Touchæµ‹è¯•å¤±è´¥ï¼Œåœæ­¢æµ‹è¯•', type: LogType.debug);
          break;
        }
        
        // æ­¥éª¤é—´å»¶è¿Ÿ
        await Future.delayed(const Duration(milliseconds: 500));
      }

      _logState?.info('', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.success('âœ… å³TouchåŠè‡ªåŠ¨åŒ–æµ‹è¯•å®Œæˆ', type: LogType.debug);
      _logState?.info('â±ï¸  ç»“æŸæ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
    } catch (e) {
      _logState?.error('å³Touchæµ‹è¯•å¼‚å¸¸: $e', type: LogType.debug);
    } finally {
      _isRightTouchTesting = false;
      // ä¿æŒå¼¹çª—æ˜¾ç¤ºï¼Œç”±ç”¨æˆ·æ‰‹åŠ¨å…³é—­
      notifyListeners();
    }
  }
  
  /// å·¦TouchåŠè‡ªåŠ¨åŒ–æµ‹è¯•
  Future<void> testTouchLeft() async {
    if (!_serialService.isConnected) {
      _logState?.error('[Touchå·¦ä¾§] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return;
    }

    _isLeftTouchTesting = true;
    _showTouchDialog = true;
    _isLeftTouchDialog = true;
    _initializeLeftTouchTestSteps();
    notifyListeners();

    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ‘† å·¦TouchåŠè‡ªåŠ¨åŒ–æµ‹è¯•å¼€å§‹', type: LogType.debug);
      _logState?.info('â±ï¸  å¼€å§‹æ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);

      // æŒ‰é¡ºåºæ‰§è¡Œæ‰€æœ‰æ­¥éª¤
      for (int stepIndex = 0; stepIndex < _leftTouchTestSteps.length; stepIndex++) {
        if (_shouldStopTest) break;
        
        final success = await _executeLeftTouchStep(stepIndex);
        if (!success) {
          _logState?.error('âŒ å·¦Touchæµ‹è¯•å¤±è´¥ï¼Œåœæ­¢æµ‹è¯•', type: LogType.debug);
          break;
        }
        
        // æ­¥éª¤é—´å»¶è¿Ÿ
        await Future.delayed(const Duration(milliseconds: 500));
      }

      _logState?.info('', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.success('âœ… å·¦TouchåŠè‡ªåŠ¨åŒ–æµ‹è¯•å®Œæˆ', type: LogType.debug);
      _logState?.info('â±ï¸  ç»“æŸæ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
    } catch (e) {
      _logState?.error('å·¦Touchæµ‹è¯•å¼‚å¸¸: $e', type: LogType.debug);
    } finally {
      _isLeftTouchTesting = false;
      // ä¿æŒå¼¹çª—æ˜¾ç¤ºï¼Œç”±ç”¨æˆ·æ‰‹åŠ¨å…³é—­
      notifyListeners();
    }
  }

  /// åˆå§‹åŒ–WiFiæµ‹è¯•æ­¥éª¤
  void _initializeWiFiTestSteps() {
    // å‡†å¤‡è¿æ¥çƒ­ç‚¹çš„æ•°æ®
    List<int>? apData;
    if (WiFiConfig.defaultSSID.isNotEmpty && WiFiConfig.defaultPassword.isNotEmpty) {
      List<int> ssidBytes = WiFiConfig.stringToBytes(WiFiConfig.defaultSSID);
      List<int> pwdBytes = WiFiConfig.stringToBytes(WiFiConfig.defaultPassword);
      apData = [...ssidBytes, ...pwdBytes];
    } else {
      apData = [0, 0]; // ç©ºçš„SSIDå’ŒPWDï¼Œéƒ½ä»¥\0ç»“å°¾
    }

    _wifiTestSteps = List<WiFiTestStep>.from([
      WiFiTestStep(
        opt: WiFiConfig.optStartTest,
        name: 'å¼€å§‹WiFiæµ‹è¯•',
        description: 'åˆå§‹åŒ–WiFiæµ‹è¯•æ¨¡å¼',
      ),
      WiFiTestStep(
        opt: WiFiConfig.optConnectAP,
        name: 'è¿æ¥çƒ­ç‚¹',
        description: 'SSID: "${WiFiConfig.defaultSSID}"',
        data: apData,
      ),
      WiFiTestStep(
        opt: WiFiConfig.optTestRSSI,
        name: 'æµ‹è¯•RSSI',
        description: 'æµ‹è¯•WiFiä¿¡å·å¼ºåº¦',
      ),
      WiFiTestStep(
        opt: WiFiConfig.optGetMAC,
        name: 'è·å–MACåœ°å€',
        description: 'è¯»å–è®¾å¤‡WiFi MACåœ°å€',
      ),
      WiFiTestStep(
        opt: WiFiConfig.optEndTest,
        name: 'ç»“æŸWiFiæµ‹è¯•',
        description: 'é€€å‡ºWiFiæµ‹è¯•æ¨¡å¼',
      ),
    ]);
    notifyListeners();
  }

  /// WiFiå¤šæ­¥éª¤æµ‹è¯•æµç¨‹
  /// æŒ‰é¡ºåºæ‰§è¡Œï¼šå¼€å§‹æµ‹è¯• -> è¿æ¥çƒ­ç‚¹ -> æµ‹è¯•RSSI -> è·å–MAC -> ç»“æŸæµ‹è¯•
  Future<bool> testWiFi() async {
    if (!_serialService.isConnected) {
      _logState?.error('[WiFi] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return false;
    }

    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸŒ å¼€å§‹WiFiå¤šæ­¥éª¤æµ‹è¯•æµç¨‹', type: LogType.debug);
      _logState?.info('â±ï¸  å¼€å§‹æ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);

      // åˆå§‹åŒ–WiFiæµ‹è¯•æ­¥éª¤
      _initializeWiFiTestSteps();

      // æ‰§è¡Œæ¯ä¸ªæ­¥éª¤
      for (int i = 0; i < _wifiTestSteps.length; i++) {
        // æ£€æŸ¥æ˜¯å¦éœ€è¦åœæ­¢æµ‹è¯•
        if (_shouldStopTest) {
          _logState?.warning('ğŸ›‘ WiFiæµ‹è¯•å·²è¢«ç”¨æˆ·åœæ­¢');
          return false;
        }

        final step = _wifiTestSteps[i];
        final success = await _executeWiFiStepWithRetry(i);
        
        if (!success) {
          _logState?.error('âŒ WiFiæµ‹è¯•å¤±è´¥: ${step.name}');
          return false;
        }
      }

      _logState?.info('', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.success('âœ… WiFiå¤šæ­¥éª¤æµ‹è¯•å®Œæˆ', type: LogType.debug);
      _logState?.info('â±ï¸  ç»“æŸæ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      
      return true;
    } catch (e) {
      _logState?.error('WiFiæµ‹è¯•å¼‚å¸¸: $e', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      return false;
    }
  }

  /// æ‰§è¡Œå•ä¸ªWiFiæµ‹è¯•æ­¥éª¤ï¼ˆå•æ¬¡æ‰§è¡Œï¼Œ5ç§’è¶…æ—¶ï¼‰
  Future<bool> _executeWiFiStepSingle(int stepIndex) async {
    final step = _wifiTestSteps[stepIndex];
    
    try {
      _logState?.info('ğŸ”„ æ­¥éª¤: ${step.name} (0x${step.opt.toRadixString(16).toUpperCase().padLeft(2, '0')})', type: LogType.debug);
      
      // åˆ›å»ºå‘½ä»¤
      final command = ProductionTestCommands.createControlWifiCommand(step.opt, data: step.data);
      
      // æ˜¾ç¤ºå‘é€çš„å‘½ä»¤
      final commandHex = command.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
      _logState?.info('ğŸ“¤ å‘é€: [$commandHex] (${command.length} bytes)', type: LogType.debug);
      
      // å¦‚æœæœ‰æ•°æ®ï¼Œæ˜¾ç¤ºæ•°æ®å†…å®¹
      if (step.data != null && step.data!.isNotEmpty) {
        if (step.opt == WiFiConfig.optConnectAP) {
          // è§£æSSIDå’ŒPWD
          int ssidEnd = step.data!.indexOf(0);
          if (ssidEnd > 0) {
            String ssid = String.fromCharCodes(step.data!.sublist(0, ssidEnd));
            List<int> pwdBytes = step.data!.sublist(ssidEnd + 1);
            int pwdEnd = pwdBytes.indexOf(0);
            String pwd = pwdEnd >= 0 ? String.fromCharCodes(pwdBytes.sublist(0, pwdEnd)) : String.fromCharCodes(pwdBytes);
            _logState?.info('   ğŸ“¡ SSID: "$ssid", PWD: "$pwd"', type: LogType.debug);
          }
        }
      }

      // å‘é€å‘½ä»¤å¹¶ç­‰å¾…å“åº”ï¼ˆ5ç§’è¶…æ—¶ï¼‰
      final response = await _serialService.sendCommandAndWaitResponse(
        command,
        timeout: const Duration(seconds: 5), // 5ç§’è¶…æ—¶
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (response != null && !response.containsKey('error')) {
        // æ˜¾ç¤ºå“åº”æ•°æ®
        if (response.containsKey('payload') && response['payload'] != null) {
          final payload = response['payload'] as Uint8List;
          final payloadHex = payload
              .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
              .join(' ');
          _logState?.info('ğŸ“¥ å“åº”: [$payloadHex] (${payload.length} bytes)', type: LogType.debug);

          // è§£æWiFiå“åº”ï¼Œä¼ å…¥å½“å‰æ‰§è¡Œçš„opt
          final wifiResult = ProductionTestCommands.parseWifiResponse(payload, step.opt);
          if (wifiResult != null && wifiResult['success'] == true) {
            String details = '';
            if (wifiResult.containsKey('rssi')) {
              details = ' - RSSI: ${wifiResult['rssi']}dBm';
            } else if (wifiResult.containsKey('mac')) {
              details = ' - MAC: ${wifiResult['mac']}';
            }
            
            // ä¿å­˜ç»“æœåˆ°æ­¥éª¤ä¸­
            final currentStep = _wifiTestSteps[stepIndex];
            _wifiTestSteps[stepIndex] = currentStep.copyWith(result: wifiResult);
            
            _logState?.success('âœ… ${step.name} æˆåŠŸ$details', type: LogType.debug);
            return true;
          } else {
            final errorMsg = wifiResult?['error'] ?? 'è§£æå“åº”å¤±è´¥';
            final currentStep = _wifiTestSteps[stepIndex];
            _wifiTestSteps[stepIndex] = currentStep.copyWith(errorMessage: errorMsg);
            _logState?.error('âŒ ${step.name} å¤±è´¥: $errorMsg', type: LogType.debug);
            return false;
          }
        } else {
          _logState?.success('âœ… ${step.name} æˆåŠŸ', type: LogType.debug);
          return true;
        }
      } else {
        final errorMsg = response?['error'] ?? 'æ— å“åº”æˆ–å“åº”é”™è¯¯';
        final currentStep = _wifiTestSteps[stepIndex];
        _wifiTestSteps[stepIndex] = currentStep.copyWith(errorMessage: errorMsg);
        _logState?.error('âŒ ${step.name} å¤±è´¥: $errorMsg', type: LogType.debug);
        return false;
      }
    } catch (e) {
      final errorMsg = 'æ‰§è¡Œå¼‚å¸¸: $e';
      final currentStep = _wifiTestSteps[stepIndex];
      _wifiTestSteps[stepIndex] = currentStep.copyWith(errorMessage: errorMsg);
      _logState?.error('âŒ ${step.name} å¼‚å¸¸: $e', type: LogType.debug);
      return false;
    }
  }

  /// æ‰§è¡Œå•ä¸ªWiFiæµ‹è¯•æ­¥éª¤
  Future<bool> _executeWiFiStep(int opt, String stepName, {List<int>? data}) async {
    try {
      _logState?.info('ğŸ”„ æ­¥éª¤: $stepName (0x${opt.toRadixString(16).toUpperCase().padLeft(2, '0')})', type: LogType.debug);
      
      // åˆ›å»ºå‘½ä»¤
      final command = ProductionTestCommands.createControlWifiCommand(opt, data: data);
      
      // æ˜¾ç¤ºå‘é€çš„å‘½ä»¤
      final commandHex = command.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
      _logState?.info('ğŸ“¤ å‘é€: [$commandHex] (${command.length} bytes)', type: LogType.debug);
      
      // å¦‚æœæœ‰æ•°æ®ï¼Œæ˜¾ç¤ºæ•°æ®å†…å®¹
      if (data != null && data.isNotEmpty) {
        if (opt == WiFiConfig.optConnectAP) {
          // è§£æSSIDå’ŒPWD
          int ssidEnd = data.indexOf(0);
          if (ssidEnd > 0) {
            String ssid = String.fromCharCodes(data.sublist(0, ssidEnd));
            List<int> pwdBytes = data.sublist(ssidEnd + 1);
            int pwdEnd = pwdBytes.indexOf(0);
            String pwd = pwdEnd >= 0 ? String.fromCharCodes(pwdBytes.sublist(0, pwdEnd)) : String.fromCharCodes(pwdBytes);
            _logState?.info('   ğŸ“¡ SSID: "$ssid", PWD: "$pwd"', type: LogType.debug);
          }
        }
      }

      // å‘é€å‘½ä»¤å¹¶ç­‰å¾…å“åº”
      final response = await _serialService.sendCommandAndWaitResponse(
        command,
        timeout: TestConfig.defaultTimeout,
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (response != null && !response.containsKey('error')) {
        // æ˜¾ç¤ºå“åº”æ•°æ®
        if (response.containsKey('payload') && response['payload'] != null) {
          final payload = response['payload'] as Uint8List;
          final payloadHex = payload
              .map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0'))
              .join(' ');
          _logState?.info('ğŸ“¥ å“åº”: [$payloadHex] (${payload.length} bytes)', type: LogType.debug);

          // è§£æWiFiå“åº”ï¼Œä¼ å…¥å½“å‰æ‰§è¡Œçš„opt
          final wifiResult = ProductionTestCommands.parseWifiResponse(payload, opt);
          if (wifiResult != null && wifiResult['success'] == true) {
            String details = '';
            if (wifiResult.containsKey('rssi')) {
              details = ' - RSSI: ${wifiResult['rssi']}dBm';
            } else if (wifiResult.containsKey('mac')) {
              details = ' - MAC: ${wifiResult['mac']}';
            }
            _logState?.success('âœ… $stepName æˆåŠŸ$details', type: LogType.debug);
            return true;
          } else {
            _logState?.error('âŒ $stepName å¤±è´¥: ${wifiResult?['error'] ?? 'è§£æå“åº”å¤±è´¥'}', type: LogType.debug);
            return false;
          }
        } else {
          _logState?.error('âŒ $stepName å¤±è´¥: å“åº”æ— payloadæ•°æ®', type: LogType.debug);
          return false;
        }
      } else {
        _logState?.error('âŒ $stepName å¤±è´¥: ${response?['error'] ?? 'æ— å“åº”'}', type: LogType.debug);
        return false;
      }
    } catch (e) {
      _logState?.error('âŒ $stepName å¼‚å¸¸: $e', type: LogType.debug);
      return false;
    }
  }

  /// IMUæ•°æ®è·å–æµ‹è¯•
  /// å¼€å§‹è·å–æ•°æ® -> æŒç»­æ¥æ”¶5ç§’ -> è¯¢é—®æ˜¯å¦ç»“æŸ -> åœæ­¢è·å–æ•°æ®
  Future<bool> testIMU() async {
    if (!_serialService.isConnected) {
      _logState?.error('[IMU] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return false;
    }

    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ“Š å¼€å§‹IMUæ•°æ®è·å–æµ‹è¯•', type: LogType.debug);
      _logState?.info('â±ï¸  å¼€å§‹æ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);

      // æ­¥éª¤1: å¼€å§‹è·å–IMUæ•°æ® (0x00)
      _logState?.info('ğŸ”„ å‘é€å¼€å§‹è·å–IMUæ•°æ®å‘½ä»¤', type: LogType.debug);
      
      final startCommand = ProductionTestCommands.createIMUCommand(ProductionTestCommands.imuOptStartData);
      final startCommandHex = startCommand.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
      _logState?.info('ğŸ“¤ å‘é€: [$startCommandHex] (${startCommand.length} bytes)', type: LogType.debug);

      // å‘é€å¼€å§‹å‘½ä»¤ï¼Œä½†ä¸ç­‰å¾…ç‰¹å®šå“åº”ï¼Œå› ä¸ºè®¾å¤‡ä¼šæŒç»­å‘é€æ•°æ®
      final startResponse = await _serialService.sendCommandAndWaitResponse(
        startCommand,
        timeout: TestConfig.defaultTimeout,
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (startResponse == null || startResponse.containsKey('error')) {
        _logState?.error('âŒ å¼€å§‹è·å–IMUæ•°æ®å¤±è´¥: ${startResponse?['error'] ?? 'æ— å“åº”'}', type: LogType.debug);
        return false;
      }

      _logState?.success('âœ… å¼€å§‹è·å–IMUæ•°æ®å‘½ä»¤å‘é€æˆåŠŸ', type: LogType.debug);
      _logState?.info('ğŸ“¡ å¼€å§‹ç›‘å¬IMUæ•°æ®æµ...', type: LogType.debug);

      // æ­¥éª¤2: æŒç»­æ¥æ”¶IMUæ•°æ®5ç§’
      int dataCount = 0;
      final startTime = DateTime.now();
      final endTime = startTime.add(const Duration(seconds: 5));
      
      // è®¾ç½®æ•°æ®æµç›‘å¬å™¨
      StreamSubscription? dataSubscription;
      bool receivedData = false;
      
      dataSubscription = _serialService.dataStream.listen((data) {
        try {
          // ç›´æ¥æ£€æŸ¥payloadç¬¬ä¸€ä¸ªå­—èŠ‚æ˜¯å¦æ˜¯IMU CMD (0x0B)
          if (data.isNotEmpty && data[0] == ProductionTestCommands.cmdIMU) {
            dataCount++;
            receivedData = true;
            
            final payloadHex = data.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
            _logState?.info('ğŸ“¥ IMUæ•°æ® #$dataCount: [$payloadHex] (${data.length} bytes)', type: LogType.debug);
            
            // è§£æIMUæ•°æ®
            final imuData = ProductionTestCommands.parseIMUResponse(data);
            if (imuData != null) {
              _logState?.info('   ğŸ“Š åŠ é€Ÿåº¦: X=${imuData['accel_x']?.toStringAsFixed(3)}, Y=${imuData['accel_y']?.toStringAsFixed(3)}, Z=${imuData['accel_z']?.toStringAsFixed(3)}', type: LogType.debug);
              _logState?.info('   ğŸ”„ é™€èºä»ª: X=${imuData['gyro_x']?.toStringAsFixed(3)}, Y=${imuData['gyro_y']?.toStringAsFixed(3)}, Z=${imuData['gyro_z']?.toStringAsFixed(3)}', type: LogType.debug);
            }
          }
        } catch (e) {
          _logState?.warning('âš ï¸  è§£æIMUæ•°æ®æ—¶å‡ºé”™: $e', type: LogType.debug);
        }
      });

      // ç­‰å¾…5ç§’
      while (DateTime.now().isBefore(endTime)) {
        await Future.delayed(const Duration(milliseconds: 100));
      }

      // å–æ¶ˆæ•°æ®ç›‘å¬
      await dataSubscription?.cancel();

      _logState?.info('', type: LogType.debug);
      _logState?.info('â° 5ç§’æ•°æ®æ”¶é›†å®Œæˆï¼Œå…±æ”¶åˆ° $dataCount æ¡IMUæ•°æ®', type: LogType.debug);

      if (!receivedData) {
        _logState?.warning('âš ï¸  æœªæ”¶åˆ°IMUæ•°æ®ï¼Œå¯èƒ½è®¾å¤‡æœªæ­£ç¡®å“åº”', type: LogType.debug);
      }

      // æ­¥éª¤3: å‘é€åœæ­¢è·å–IMUæ•°æ®å‘½ä»¤ (0x01)
      _logState?.info('ğŸ›‘ å‘é€åœæ­¢è·å–IMUæ•°æ®å‘½ä»¤', type: LogType.debug);
      
      final stopCommand = ProductionTestCommands.createIMUCommand(ProductionTestCommands.imuOptStopData);
      final stopCommandHex = stopCommand.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
      _logState?.info('ğŸ“¤ å‘é€: [$stopCommandHex] (${stopCommand.length} bytes)', type: LogType.debug);

      final stopResponse = await _serialService.sendCommandAndWaitResponse(
        stopCommand,
        timeout: TestConfig.defaultTimeout,
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (stopResponse != null && !stopResponse.containsKey('error')) {
        // æ˜¾ç¤ºåœæ­¢å“åº”
        if (stopResponse.containsKey('payload') && stopResponse['payload'] != null) {
          final payload = stopResponse['payload'] as Uint8List;
          final payloadHex = payload.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
          _logState?.info('ğŸ“¥ åœæ­¢å“åº”: [$payloadHex] (${payload.length} bytes)', type: LogType.debug);
        }
        
        _logState?.success('âœ… åœæ­¢è·å–IMUæ•°æ®æˆåŠŸ', type: LogType.debug);
        
        _logState?.info('', type: LogType.debug);
        _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
        _logState?.success('âœ… IMUæ•°æ®è·å–æµ‹è¯•å®Œæˆ', type: LogType.debug);
        _logState?.info('ğŸ“Š æ€»å…±æ”¶åˆ° $dataCount æ¡IMUæ•°æ®', type: LogType.debug);
        _logState?.info('â±ï¸  ç»“æŸæ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
        _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
        
        return receivedData; // åªè¦æ”¶åˆ°äº†æ•°æ®å°±è®¤ä¸ºæµ‹è¯•æˆåŠŸ
      } else {
        _logState?.error('âŒ åœæ­¢è·å–IMUæ•°æ®å¤±è´¥: ${stopResponse?['error'] ?? 'æ— å“åº”'}', type: LogType.debug);
        _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
        return false;
      }
    } catch (e) {
      _logState?.error('IMUæµ‹è¯•å¼‚å¸¸: $e', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      return false;
    }
  }
  
  /// åˆå§‹åŒ–å·¦Touchæµ‹è¯•æ­¥éª¤
  void _initializeLeftTouchTestSteps() {
    _leftTouchTestSteps = [
      TouchTestStep(
        touchId: TouchTestConfig.touchLeft,
        actionId: TouchTestConfig.leftActionSingleTap,
        name: 'å•å‡»æµ‹è¯•',
        description: 'æµ‹è¯•å·¦ä¾§Touchå•å‡»åŠŸèƒ½',
        userPrompt: TouchTestConfig.getLeftActionPrompt(TouchTestConfig.leftActionSingleTap),
      ),
      TouchTestStep(
        touchId: TouchTestConfig.touchLeft,
        actionId: TouchTestConfig.leftActionDoubleTap,
        name: 'åŒå‡»æµ‹è¯•',
        description: 'æµ‹è¯•å·¦ä¾§TouchåŒå‡»åŠŸèƒ½',
        userPrompt: TouchTestConfig.getLeftActionPrompt(TouchTestConfig.leftActionDoubleTap),
      ),
      TouchTestStep(
        touchId: TouchTestConfig.touchLeft,
        actionId: TouchTestConfig.leftActionLongPress,
        name: 'é•¿æŒ‰æµ‹è¯•',
        description: 'æµ‹è¯•å·¦ä¾§Touché•¿æŒ‰åŠŸèƒ½',
        userPrompt: TouchTestConfig.getLeftActionPrompt(TouchTestConfig.leftActionLongPress),
      ),
      TouchTestStep(
        touchId: TouchTestConfig.touchLeft,
        actionId: TouchTestConfig.leftActionWearDetect,
        name: 'ä½©æˆ´æ£€æµ‹',
        description: 'æµ‹è¯•å·¦ä¾§Touchä½©æˆ´æ£€æµ‹åŠŸèƒ½',
        userPrompt: TouchTestConfig.getLeftActionPrompt(TouchTestConfig.leftActionWearDetect),
      ),
    ];
    notifyListeners();
  }
  
  /// åˆå§‹åŒ–å³Touchæµ‹è¯•æ­¥éª¤
  void _initializeRightTouchTestSteps() {
    _rightTouchTestSteps = [
      TouchTestStep(
        touchId: TouchTestConfig.touchRight,
        actionId: TouchTestConfig.rightAreaUntouched,
        name: 'è·å–åŸºçº¿å€¼',
        description: 'è·å–æœªè§¦æ‘¸æ—¶çš„CDCåŸºçº¿å€¼',
        userPrompt: TouchTestConfig.getRightAreaPrompt(TouchTestConfig.rightAreaUntouched),
      ),
      TouchTestStep(
        touchId: TouchTestConfig.touchRight,
        actionId: TouchTestConfig.rightAreaTK1,
        name: 'TK1æµ‹è¯•',
        description: 'æµ‹è¯•å³ä¾§TK1åŒºåŸŸè§¦æ‘¸åŠŸèƒ½',
        userPrompt: TouchTestConfig.getRightAreaPrompt(TouchTestConfig.rightAreaTK1),
      ),
      TouchTestStep(
        touchId: TouchTestConfig.touchRight,
        actionId: TouchTestConfig.rightAreaTK2,
        name: 'TK2æµ‹è¯•',
        description: 'æµ‹è¯•å³ä¾§TK2åŒºåŸŸè§¦æ‘¸åŠŸèƒ½',
        userPrompt: TouchTestConfig.getRightAreaPrompt(TouchTestConfig.rightAreaTK2),
      ),
      TouchTestStep(
        touchId: TouchTestConfig.touchRight,
        actionId: TouchTestConfig.rightAreaTK3,
        name: 'TK3æµ‹è¯•',
        description: 'æµ‹è¯•å³ä¾§TK3åŒºåŸŸè§¦æ‘¸åŠŸèƒ½',
        userPrompt: TouchTestConfig.getRightAreaPrompt(TouchTestConfig.rightAreaTK3),
      ),
    ];
    notifyListeners();
  }
  
  /// æ‰§è¡Œå·¦Touchæµ‹è¯•æ­¥éª¤
  Future<bool> _executeLeftTouchStep(int stepIndex) async {
    final step = _leftTouchTestSteps[stepIndex];
    
    try {
      // æ›´æ–°æ­¥éª¤çŠ¶æ€ä¸ºæ­£åœ¨æµ‹è¯•
      _leftTouchTestSteps[stepIndex] = step.copyWith(status: TouchStepStatus.testing);
      notifyListeners();
      
      _logState?.info('ğŸ”„ æ­¥éª¤: ${step.name}', type: LogType.debug);
      _logState?.info('ğŸ“ æè¿°: ${step.description}', type: LogType.debug);
      
      // å·¦Touchæ‰€æœ‰æ­¥éª¤éƒ½éœ€è¦ç”¨æˆ·æ“ä½œå’Œç›‘å¬
      return await _waitForLeftTouchUserAction(step, stepIndex);
      
    } catch (e) {
      _leftTouchTestSteps[stepIndex] = step.copyWith(
        status: TouchStepStatus.failed,
        errorMessage: 'æ‰§è¡Œå¼‚å¸¸: $e',
      );
      notifyListeners();
      _logState?.error('âŒ ${step.name} å¼‚å¸¸: $e', type: LogType.debug);
      return false;
    }
  }
  
  /// æ‰§è¡Œå³Touchæµ‹è¯•æ­¥éª¤
  Future<bool> _executeRightTouchStep(int stepIndex) async {
    final step = _rightTouchTestSteps[stepIndex];
    
    try {
      // æ›´æ–°æ­¥éª¤çŠ¶æ€ä¸ºæ­£åœ¨æµ‹è¯•
      _rightTouchTestSteps[stepIndex] = step.copyWith(status: TouchStepStatus.testing);
      notifyListeners();
      
      _logState?.info('ğŸ”„ æ­¥éª¤: ${step.name}', type: LogType.debug);
      _logState?.info('ğŸ“ æè¿°: ${step.description}', type: LogType.debug);
      
      // å¦‚æœæ˜¯ç¬¬ä¸€æ­¥ï¼ˆè·å–åŸºçº¿å€¼ï¼‰ï¼Œç›´æ¥å‘é€å‘½ä»¤
      if (stepIndex == 0) {
        return await _getRightTouchBaselineCdcValue(step, stepIndex);
      }
      
      // å…¶ä»–æ­¥éª¤éœ€è¦ç”¨æˆ·æ“ä½œ
      return await _waitForUserActionAndGetCdc(step, stepIndex);
      
    } catch (e) {
      _rightTouchTestSteps[stepIndex] = step.copyWith(
        status: TouchStepStatus.failed,
        errorMessage: 'æ‰§è¡Œå¼‚å¸¸: $e',
      );
      notifyListeners();
      _logState?.error('âŒ ${step.name} å¼‚å¸¸: $e', type: LogType.debug);
      return false;
    }
  }
  
  /// è·å–å³TouchåŸºçº¿ CDC å€¼
  Future<bool> _getRightTouchBaselineCdcValue(TouchTestStep step, int stepIndex) async {
    _logState?.info('ğŸ“¡ è·å–å³TouchåŸºçº¿ CDC å€¼...', type: LogType.debug);
    
    // åˆ›å»ºå‘½ä»¤
    final command = ProductionTestCommands.createTouchCommand(step.touchId, step.actionId);
    
    // æ˜¾ç¤ºå‘é€çš„å‘½ä»¤
    final commandHex = command.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
    _logState?.info('ğŸ“¤ å‘é€: [$commandHex]', type: LogType.debug);
    
    // å‘é€å‘½ä»¤å¹¶ç­‰å¾…å“åº”
    final response = await _serialService.sendCommandAndWaitResponse(
      command,
      timeout: const Duration(seconds: 5),
      moduleId: ProductionTestCommands.moduleId,
      messageId: ProductionTestCommands.messageId,
    );
    
    if (response != null && !response.containsKey('error')) {
      if (response.containsKey('payload') && response['payload'] != null) {
        final payload = response['payload'] as Uint8List;
        final payloadHex = payload.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
        _logState?.info('ğŸ“¥ å“åº”: [$payloadHex]', type: LogType.debug);
        
        // è§£æTouchå“åº”
        final touchResult = ProductionTestCommands.parseTouchResponse(payload);
        if (touchResult != null && touchResult['success'] == true) {
          _baselineCdcValue = touchResult['cdcValue'];
          
          // æ›´æ–°æ­¥éª¤çŠ¶æ€
          _rightTouchTestSteps[stepIndex] = step.copyWith(
            status: TouchStepStatus.success,
            cdcValue: _baselineCdcValue,
          );
          notifyListeners();
          
          _logState?.success('âœ… å³TouchåŸºçº¿ CDC å€¼: $_baselineCdcValue', type: LogType.debug);
          return true;
        } else {
          final errorMsg = touchResult?['error'] ?? 'è§£æå“åº”å¤±è´¥';
          _logState?.error('âŒ è·å–å³TouchåŸºçº¿ CDC å€¼å¤±è´¥: $errorMsg', type: LogType.debug);
          return false;
        }
      }
    }
    
    _logState?.error('âŒ è·å–å³TouchåŸºçº¿ CDC å€¼å¤±è´¥: æ— å“åº”', type: LogType.debug);
    return false;
  }
  
  /// ç­‰å¾…å·¦Touchç”¨æˆ·æ“ä½œï¼ˆä¸è·å–CDCå€¼ï¼Œå¸¦é‡è¯•æœºåˆ¶ï¼‰
  Future<bool> _waitForLeftTouchUserAction(TouchTestStep step, int stepIndex) async {
    const maxRetries = 10;
    
    for (int retry = 0; retry <= maxRetries; retry++) {
      if (retry > 0) {
        _logState?.warning('ğŸ”„ é‡è¯•ç¬¬ $retry æ¬¡: ${step.name}', type: LogType.debug);
        await Future.delayed(const Duration(milliseconds: 500));
      }
      
      final success = await _executeSingleLeftTouchStep(step, stepIndex, retry);
      if (success) {
        return true;
      }
      
      // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡é‡è¯•ï¼Œç»§ç»­
      if (retry < maxRetries) {
        await Future.delayed(const Duration(milliseconds: 1000));
      }
    }
    
    // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
    _leftTouchTestSteps[stepIndex] = step.copyWith(
      status: TouchStepStatus.failed,
      errorMessage: 'é‡è¯• $maxRetries æ¬¡åä»ç„¶å¤±è´¥',
      currentRetry: maxRetries,
    );
    notifyListeners();
    
    _logState?.error('âŒ ${step.name} é‡è¯• $maxRetries æ¬¡åä»ç„¶å¤±è´¥', type: LogType.debug);
    return false;
  }
  
  /// æ‰§è¡Œå•æ¬¡å·¦Touchæ­¥éª¤
  Future<bool> _executeSingleLeftTouchStep(TouchTestStep step, int stepIndex, int currentRetry) async {
    // æ›´æ–°æ­¥éª¤çŠ¶æ€ä¸ºç­‰å¾…ç”¨æˆ·æ“ä½œ
    _leftTouchTestSteps[stepIndex] = step.copyWith(status: TouchStepStatus.userAction);
    notifyListeners();
    
    _logState?.info('ğŸ‘† ${step.userPrompt}', type: LogType.debug);
    _logState?.info('â³ ç­‰å¾…ç”¨æˆ·æ“ä½œä¸­... (è¯·åœ¨ 10 ç§’å†…å®Œæˆæ“ä½œ)', type: LogType.debug);
    
    // åˆ›å»ºå‘½ä»¤
    final command = ProductionTestCommands.createTouchCommand(step.touchId, step.actionId);
    
    // æ˜¾ç¤ºå‘é€çš„å‘½ä»¤
    final commandHex = command.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
    _logState?.info('ğŸ“¤ å‘é€: [$commandHex]', type: LogType.debug);
    
    // ç­‰å¾…ç”¨æˆ·æ“ä½œçš„æ—¶é—´
    await Future.delayed(const Duration(seconds: 2));
    
    // å‘é€å‘½ä»¤å¹¶ç­‰å¾…å“åº”ï¼ˆ10ç§’è¶…æ—¶ï¼‰
    final response = await _serialService.sendCommandAndWaitResponse(
      command,
      timeout: const Duration(seconds: 10),
      moduleId: ProductionTestCommands.moduleId,
      messageId: ProductionTestCommands.messageId,
    );
    
    if (response != null && !response.containsKey('error')) {
      if (response.containsKey('payload') && response['payload'] != null) {
        final payload = response['payload'] as Uint8List;
        final payloadHex = payload.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
        _logState?.info('ğŸ“¥ å“åº”: [$payloadHex]', type: LogType.debug);
        
        // è§£æTouchå“åº”
        final touchResult = ProductionTestCommands.parseTouchResponse(payload);
        if (touchResult != null && touchResult['success'] == true) {
          // æ›´æ–°æ­¥éª¤çŠ¶æ€
          _leftTouchTestSteps[stepIndex] = step.copyWith(
            status: TouchStepStatus.success,
            currentRetry: currentRetry,
          );
          notifyListeners();
          
          _logState?.success('âœ… ${step.name} æˆåŠŸ', type: LogType.debug);
          return true;
        } else {
          final errorMsg = touchResult?['error'] ?? 'è§£æå“åº”å¤±è´¥';
          
          _leftTouchTestSteps[stepIndex] = step.copyWith(
            status: TouchStepStatus.testing,
            currentRetry: currentRetry,
            errorMessage: errorMsg,
          );
          notifyListeners();
          
          _logState?.error('âŒ ${step.name} è§£æå¤±è´¥: $errorMsg', type: LogType.debug);
          return false;
        }
      }
    }
    
    // è¶…æ—¶æˆ–æ— å“åº”
    _leftTouchTestSteps[stepIndex] = step.copyWith(
      status: TouchStepStatus.testing,
      currentRetry: currentRetry,
      errorMessage: 'è¶…æ—¶æˆ–æ— å“åº”',
    );
    notifyListeners();
    
    _logState?.error('âŒ ${step.name} è¶…æ—¶æˆ–æ— å“åº”', type: LogType.debug);
    return false;
  }
  
  /// ç­‰å¾…å³Touchç”¨æˆ·æ“ä½œå¹¶è·å– CDC å€¼ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
  Future<bool> _waitForUserActionAndGetCdc(TouchTestStep step, int stepIndex) async {
    const maxRetries = 10;
    
    for (int retry = 0; retry <= maxRetries; retry++) {
      if (retry > 0) {
        _logState?.warning('ğŸ”„ é‡è¯•ç¬¬ $retry æ¬¡: ${step.name}', type: LogType.debug);
        await Future.delayed(const Duration(milliseconds: 500));
      }
      
      final success = await _executeSingleRightTouchStep(step, stepIndex, retry);
      if (success) {
        return true;
      }
      
      // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡é‡è¯•ï¼Œç»§ç»­
      if (retry < maxRetries) {
        await Future.delayed(const Duration(milliseconds: 1000));
      }
    }
    
    // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
    _rightTouchTestSteps[stepIndex] = step.copyWith(
      status: TouchStepStatus.failed,
      errorMessage: 'é‡è¯• $maxRetries æ¬¡åä»ç„¶å¤±è´¥',
      currentRetry: maxRetries,
    );
    notifyListeners();
    
    _logState?.error('âŒ ${step.name} é‡è¯• $maxRetries æ¬¡åä»ç„¶å¤±è´¥', type: LogType.debug);
    return false;
  }
  
  /// æ‰§è¡Œå•æ¬¡å³Touchæ­¥éª¤
  Future<bool> _executeSingleRightTouchStep(TouchTestStep step, int stepIndex, int currentRetry) async {
    // æ›´æ–°æ­¥éª¤çŠ¶æ€ä¸ºç­‰å¾…ç”¨æˆ·æ“ä½œ
    _rightTouchTestSteps[stepIndex] = step.copyWith(status: TouchStepStatus.userAction);
    notifyListeners();
    
    _logState?.info('ğŸ‘† ${step.userPrompt}', type: LogType.debug);
    _logState?.info('â³ ç­‰å¾…ç”¨æˆ·æ“ä½œä¸­... (è¯·åœ¨ 10 ç§’å†…å®Œæˆæ“ä½œ)', type: LogType.debug);
    
    // åˆ›å»ºå‘½ä»¤
    final command = ProductionTestCommands.createTouchCommand(step.touchId, step.actionId);
    
    // æ˜¾ç¤ºå‘é€çš„å‘½ä»¤
    final commandHex = command.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
    _logState?.info('ğŸ“¤ å‘é€: [$commandHex]', type: LogType.debug);
    
    // ç­‰å¾…ç”¨æˆ·æ“ä½œçš„æ—¶é—´
    await Future.delayed(const Duration(seconds: 2));
    
    // å‘é€å‘½ä»¤å¹¶ç­‰å¾…å“åº”ï¼ˆ10ç§’è¶…æ—¶ï¼‰
    final response = await _serialService.sendCommandAndWaitResponse(
      command,
      timeout: const Duration(seconds: 10),
      moduleId: ProductionTestCommands.moduleId,
      messageId: ProductionTestCommands.messageId,
    );
    
    if (response != null && !response.containsKey('error')) {
      if (response.containsKey('payload') && response['payload'] != null) {
        final payload = response['payload'] as Uint8List;
        final payloadHex = payload.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
        _logState?.info('ğŸ“¥ å“åº”: [$payloadHex]', type: LogType.debug);
        
        // è§£æTouchå“åº”
        final touchResult = ProductionTestCommands.parseTouchResponse(payload);
        if (touchResult != null && touchResult['success'] == true) {
          final cdcValue = touchResult['cdcValue'];
          
          // è®¡ç®—CDCå·®å€¼
          int? cdcDiff;
          bool thresholdMet = true;
          String details = 'CDC: $cdcValue';
          
          if (_baselineCdcValue != null) {
            cdcDiff = (cdcValue - _baselineCdcValue!).abs();
            details += ' (å·®å€¼: ${cdcValue > _baselineCdcValue! ? '+' : '-'}$cdcDiff)';
            
            // æ£€æŸ¥CDCå·®å€¼æ˜¯å¦è¶…è¿‡é˜ˆå€¼
            if (cdcDiff != null && cdcDiff < TouchTestConfig.cdcThreshold) {
              thresholdMet = false;
              details += ' [æœªè¾¾é˜ˆå€¼ ${TouchTestConfig.cdcThreshold}]';
            }
          }
          
          if (thresholdMet) {
            // CDCå·®å€¼è¶…è¿‡é˜ˆå€¼ï¼Œæµ‹è¯•æˆåŠŸ
            _rightTouchTestSteps[stepIndex] = step.copyWith(
              status: TouchStepStatus.success,
              cdcValue: cdcValue,
              cdcDiff: cdcDiff,
              currentRetry: currentRetry,
            );
            notifyListeners();
            
            _logState?.success('âœ… ${step.name} æˆåŠŸ - $details', type: LogType.debug);
            return true;
          } else {
            // CDCå·®å€¼æœªè¾¾é˜ˆå€¼ï¼Œéœ€è¦é‡è¯•
            _rightTouchTestSteps[stepIndex] = step.copyWith(
              status: TouchStepStatus.testing,
              cdcValue: cdcValue,
              cdcDiff: cdcDiff,
              currentRetry: currentRetry,
              errorMessage: 'CDCå·®å€¼ $cdcDiff æœªè¾¾é˜ˆå€¼ ${TouchTestConfig.cdcThreshold}',
            );
            notifyListeners();
            
            _logState?.warning('âš ï¸ ${step.name} CDCå·®å€¼ä¸è¶³ - $details', type: LogType.debug);
            return false;
          }
        } else {
          final errorMsg = touchResult?['error'] ?? 'è§£æå“åº”å¤±è´¥';
          
          _rightTouchTestSteps[stepIndex] = step.copyWith(
            status: TouchStepStatus.testing,
            currentRetry: currentRetry,
            errorMessage: errorMsg,
          );
          notifyListeners();
          
          _logState?.error('âŒ ${step.name} è§£æå¤±è´¥: $errorMsg', type: LogType.debug);
          return false;
        }
      }
    }
    
    // è¶…æ—¶æˆ–æ— å“åº”
    _rightTouchTestSteps[stepIndex] = step.copyWith(
      status: TouchStepStatus.testing,
      currentRetry: currentRetry,
      errorMessage: 'è¶…æ—¶æˆ–æ— å“åº”',
    );
    notifyListeners();
    
    _logState?.error('âŒ ${step.name} è¶…æ—¶æˆ–æ— å“åº”', type: LogType.debug);
    return false;
  }
  
  /// é‡è¯•å³Touchæ­¥éª¤
  Future<void> retryRightTouchStep(int stepIndex) async {
    if (stepIndex < 0 || stepIndex >= _rightTouchTestSteps.length) return;
    
    final step = _rightTouchTestSteps[stepIndex];
    
    // é‡ç½®æ­¥éª¤çŠ¶æ€
    _rightTouchTestSteps[stepIndex] = step.copyWith(
      status: TouchStepStatus.waiting,
      currentRetry: 0,
      errorMessage: null,
    );
    notifyListeners();
    
    _logState?.info('ğŸ”„ é‡æ–°å¼€å§‹: ${step.name}', type: LogType.debug);
    
    // æ‰§è¡Œæ­¥éª¤
    if (stepIndex == 0) {
      await _getRightTouchBaselineCdcValue(step, stepIndex);
    } else {
      await _waitForUserActionAndGetCdc(step, stepIndex);
    }
  }
  
  /// è·³è¿‡å³Touchæ­¥éª¤
  void skipRightTouchStep(int stepIndex) {
    if (stepIndex < 0 || stepIndex >= _rightTouchTestSteps.length) return;
    
    final step = _rightTouchTestSteps[stepIndex];
    
    _rightTouchTestSteps[stepIndex] = step.copyWith(
      status: TouchStepStatus.skipped,
      isSkipped: true,
    );
    notifyListeners();
    
    _logState?.info('â­ï¸ è·³è¿‡æ­¥éª¤: ${step.name}', type: LogType.debug);
  }
  
  /// é‡è¯•å·¦Touchæ­¥éª¤
  Future<void> retryLeftTouchStep(int stepIndex) async {
    if (stepIndex < 0 || stepIndex >= _leftTouchTestSteps.length) return;
    
    final step = _leftTouchTestSteps[stepIndex];
    
    // é‡ç½®æ­¥éª¤çŠ¶æ€
    _leftTouchTestSteps[stepIndex] = step.copyWith(
      status: TouchStepStatus.waiting,
      currentRetry: 0,
      errorMessage: null,
    );
    notifyListeners();
    
    _logState?.info('ğŸ”„ é‡æ–°å¼€å§‹: ${step.name}', type: LogType.debug);
    
    // æ‰§è¡Œæ­¥éª¤
    await _waitForLeftTouchUserAction(step, stepIndex);
  }
  
  /// è·³è¿‡å·¦Touchæ­¥éª¤
  void skipLeftTouchStep(int stepIndex) {
    if (stepIndex < 0 || stepIndex >= _leftTouchTestSteps.length) return;
    
    final step = _leftTouchTestSteps[stepIndex];
    
    _leftTouchTestSteps[stepIndex] = step.copyWith(
      status: TouchStepStatus.skipped,
      isSkipped: true,
    );
    notifyListeners();
    
    _logState?.info('â­ï¸ è·³è¿‡æ­¥éª¤: ${step.name}', type: LogType.debug);
  }

  /// å¼€å§‹Sensoræµ‹è¯•
  /// å‘é€å¼€å§‹å‘½ä»¤ï¼Œç„¶åç›‘å¬sensoræ¨é€çš„æ•°æ®ï¼Œæ˜¾ç¤ºåœ¨å¼¹çª—ä¸­
  Future<bool> startSensorTest() async {
    if (!_serialService.isConnected) {
      _logState?.error('[Sensor] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return false;
    }

    if (_isSensorTesting) {
      _logState?.warning('[Sensor] å·²åœ¨æµ‹è¯•ä¸­', type: LogType.debug);
      return false;
    }

    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ“Š å¼€å§‹Sensoræµ‹è¯•', type: LogType.debug);
      _logState?.info('â±ï¸  å¼€å§‹æ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);

      // å‘é€å¼€å§‹sensoræµ‹è¯•å‘½ä»¤ (0x0C, 0x00)
      _logState?.info('ğŸ”„ å‘é€å¼€å§‹sensoræµ‹è¯•å‘½ä»¤', type: LogType.debug);
      
      final startCommand = ProductionTestCommands.createSensorCommand(ProductionTestCommands.sensorOptStart);
      final startCommandHex = startCommand.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
      _logState?.info('ğŸ“¤ å‘é€: [$startCommandHex] (${startCommand.length} bytes)', type: LogType.debug);

      // å‘é€å¼€å§‹å‘½ä»¤ï¼Œå¸¦é‡è¯•æœºåˆ¶
      Map<String, dynamic>? startResponse;
      int retryCount = 0;
      const maxRetries = 10;
      
      while (retryCount <= maxRetries && startResponse == null) {
        if (retryCount > 0) {
          _logState?.warning('ğŸ”„ é‡è¯•ç¬¬ $retryCount æ¬¡å‘é€å¼€å§‹å‘½ä»¤', type: LogType.debug);
          await Future.delayed(const Duration(seconds: 5)); // æ¯æ¬¡è¶…æ—¶æ—¶é—´ 5s
        }
        
        startResponse = await _serialService.sendCommandAndWaitResponse(
          startCommand,
          timeout: const Duration(seconds: 5),
          moduleId: ProductionTestCommands.moduleId,
          messageId: ProductionTestCommands.messageId,
        );
        
        retryCount++;
      }

      if (startResponse == null || startResponse.containsKey('error')) {
        _logState?.error('âŒ å¼€å§‹sensoræµ‹è¯•å¤±è´¥: ${startResponse?['error'] ?? 'æ— å“åº”ï¼Œå·²é‡è¯• $maxRetries æ¬¡'}', type: LogType.debug);
        return false;
      }

      _logState?.success('âœ… å¼€å§‹sensoræµ‹è¯•å‘½ä»¤å‘é€æˆåŠŸ', type: LogType.debug);
      
      // è®¾ç½®æµ‹è¯•çŠ¶æ€
      _isSensorTesting = true;
      _showSensorDialog = true;
      _sensorDataList.clear();
      notifyListeners();

      // å¼€å§‹ç›‘å¬sensoræ•°æ®
      _logState?.info('ğŸ“¡ å¼€å§‹ç›‘å¬sensoræ•°æ®æµ...', type: LogType.debug);
      _startSensorDataListener();

      return true;
    } catch (e) {
      _logState?.error('Sensoræµ‹è¯•å¼‚å¸¸: $e', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      return false;
    }
  }

  /// åœæ­¢Sensoræµ‹è¯•
  Future<bool> stopSensorTest() async {
    if (!_serialService.isConnected) {
      _logState?.error('[Sensor] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return false;
    }

    if (!_isSensorTesting) {
      _logState?.warning('[Sensor] æœªåœ¨æµ‹è¯•ä¸­', type: LogType.debug);
      return false;
    }

    try {
      // å‘é€åœæ­¢sensoræµ‹è¯•å‘½ä»¤ (0x0C, 0xFF)
      _logState?.info('ğŸ›‘ å‘é€åœæ­¢sensoræµ‹è¯•å‘½ä»¤', type: LogType.debug);
      
      final stopCommand = ProductionTestCommands.createSensorCommand(ProductionTestCommands.sensorOptStop);
      final stopCommandHex = stopCommand.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
      _logState?.info('ğŸ“¤ å‘é€: [$stopCommandHex] (${stopCommand.length} bytes)', type: LogType.debug);

      final stopResponse = await _serialService.sendCommandAndWaitResponse(
        stopCommand,
        timeout: const Duration(seconds: 5),
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (stopResponse != null && !stopResponse.containsKey('error')) {
        _logState?.success('âœ… åœæ­¢sensoræµ‹è¯•æˆåŠŸ', type: LogType.debug);
        
        // åœæ­¢æ•°æ®ç›‘å¬
        await _sensorDataSubscription?.cancel();
        _sensorDataSubscription = null;
        
        // æ›´æ–°çŠ¶æ€
        _isSensorTesting = false;
        notifyListeners();
        
        _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
        _logState?.success('âœ… Sensoræµ‹è¯•å®Œæˆï¼Œå…±æ”¶åˆ° ${_sensorDataList.length} æ¡æ•°æ®', type: LogType.debug);
        _logState?.info('â±ï¸  ç»“æŸæ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
        _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
        
        return true;
      } else {
        _logState?.error('âŒ åœæ­¢sensoræµ‹è¯•å¤±è´¥: ${stopResponse?['error'] ?? 'æ— å“åº”'}', type: LogType.debug);
        return false;
      }
    } catch (e) {
      _logState?.error('åœæ­¢Sensoræµ‹è¯•å¼‚å¸¸: $e', type: LogType.debug);
      return false;
    }
  }

  /// å¼€å§‹ç›‘å¬sensoræ•°æ®
  void _startSensorDataListener() {
    _sensorDataSubscription = _serialService.dataStream.listen((data) {
      try {
        // ç›´æ¥æ£€æŸ¥payloadç¬¬ä¸€ä¸ªå­—èŠ‚æ˜¯å¦æ˜¯Sensor CMD (0x0C)
        if (data.isNotEmpty && data[0] == ProductionTestCommands.cmdSensor) {
          final sensorResult = ProductionTestCommands.parseSensorResponse(data);
          if (sensorResult != null && sensorResult['success'] == true) {
            _handleSensorDataPacket(sensorResult);
          }
        }
      } catch (e) {
        _logState?.warning('âš ï¸  è§£æSensoræ•°æ®æ—¶å‡ºé”™: $e', type: LogType.debug);
      }
    });
  }

  /// å¤„ç†sensoræ•°æ®åŒ…
  void _handleSensorDataPacket(Map<String, dynamic> packet) {
    final now = DateTime.now();
    
    // é‡ç½®åŒ…é—´è¶…æ—¶è®¡æ—¶å™¨
    _packetTimeoutTimer?.cancel();
    
    if (packet['type'] == 'command_ack') {
      // å‘½ä»¤ç¡®è®¤åŒ…
      _logState?.info('ğŸ“¥ æ”¶åˆ°Sensorå‘½ä»¤ç¡®è®¤', type: LogType.debug);
      return;
    }
    
    if (packet['type'] == 'image_data') {
      // å›¾ç‰‡æ•°æ®åŒ…
      final picTotalBytes = packet['picTotalBytes'] as int;
      final dataIndex = packet['dataIndex'] as int;
      final dataLen = packet['dataLen'] as int;
      final data = packet['data'] as Uint8List;
      final isLastPacket = packet['isLastPacket'] as bool;
      
      // æ£€æŸ¥åŒ…é—´è¶…æ—¶ï¼ˆ5ç§’ï¼‰
      if (_lastPacketTime != null && now.difference(_lastPacketTime!).inSeconds > 5) {
        _logState?.error('âŒ åŒ…é—´è¶…æ—¶ï¼ˆ>5ç§’ï¼‰ï¼Œå‡†å¤‡é‡è¯•', type: LogType.debug);
        _retrySensorTest();
        return;
      }
      
      // åˆå§‹åŒ–å›¾ç‰‡ç¼“å†²åŒº
      if (_expectedTotalBytes == null) {
        _expectedTotalBytes = picTotalBytes;
        _imageBuffer = List<int>.filled(picTotalBytes, 0);
        _logState?.info('ğŸ“Š å¼€å§‹æ¥æ”¶å›¾ç‰‡æ•°æ®ï¼Œæ€»å¤§å°: $picTotalBytes å­—èŠ‚', type: LogType.debug);
      }
      
      // éªŒè¯æ€»å¤§å°ä¸€è‡´æ€§
      if (_expectedTotalBytes != picTotalBytes) {
        _logState?.error('âŒ å›¾ç‰‡æ€»å¤§å°ä¸ä¸€è‡´ï¼ŒæœŸæœ›: $_expectedTotalBytes, å®é™…: $picTotalBytes', type: LogType.debug);
        _retrySensorTest();
        return;
      }
      
      // å¤åˆ¶æ•°æ®åˆ°ç¼“å†²åŒº
      for (int i = 0; i < dataLen; i++) {
        if (dataIndex + i < _imageBuffer.length) {
          _imageBuffer[dataIndex + i] = data[i];
        }
      }
      
      _lastPacketTime = now;
      
      // è®°å½•æ•°æ®åŒ…ä¿¡æ¯
      final packetInfo = {
        'timestamp': now.toString(),
        'index': _sensorDataList.length + 1,
        'picTotalBytes': picTotalBytes,
        'dataIndex': dataIndex,
        'dataLen': dataLen,
        'isLastPacket': isLastPacket,
        'progress': ((dataIndex + dataLen) / picTotalBytes * 100).toStringAsFixed(1),
      };
      
      _sensorDataList.add(packetInfo);
      notifyListeners();
      
      _logState?.info('ğŸ“¥ å›¾ç‰‡æ•°æ®åŒ… #${packetInfo['index']}: åç§»=$dataIndex, é•¿åº¦=$dataLen, è¿›åº¦=${packetInfo['progress']}%', type: LogType.debug);
      
      // è®¾ç½®ä¸‹ä¸€ä¸ªåŒ…çš„è¶…æ—¶è®¡æ—¶å™¨ï¼ˆ5ç§’ï¼‰
      if (!isLastPacket) {
        _packetTimeoutTimer = Timer(const Duration(seconds: 5), () {
          _logState?.error('âŒ ç­‰å¾…ä¸‹ä¸€åŒ…è¶…æ—¶ï¼ˆ5ç§’ï¼‰ï¼Œå‡†å¤‡é‡è¯•', type: LogType.debug);
          _retrySensorTest();
        });
      } else {
        // æœ€åä¸€ä¸ªåŒ…ï¼ŒéªŒè¯å®Œæ•´æ€§å¹¶æ˜¾ç¤ºå›¾ç‰‡
        _logState?.success('âœ… å›¾ç‰‡æ•°æ®æ¥æ”¶å®Œæˆï¼', type: LogType.debug);
        _handleImageComplete();
      }
    }
  }

  /// å¤„ç†å›¾ç‰‡æ¥æ”¶å®Œæˆ
  void _handleImageComplete() {
    _sensorTimeoutTimer?.cancel();
    _packetTimeoutTimer?.cancel();
    
    try {
      // åˆ›å»ºå›¾ç‰‡æ•°æ®
      final imageData = Uint8List.fromList(_imageBuffer);
      
      // æ·»åŠ å®ŒæˆçŠ¶æ€åˆ°æ•°æ®åˆ—è¡¨
      final completeInfo = {
        'timestamp': DateTime.now().toString(),
        'index': _sensorDataList.length + 1,
        'type': 'image_complete',
        'imageData': imageData,
        'totalBytes': _expectedTotalBytes,
        'message': 'å›¾ç‰‡æ¥æ”¶å®Œæˆï¼Œç­‰å¾…ç”¨æˆ·ç¡®è®¤',
      };
      
      _sensorDataList.add(completeInfo);
      notifyListeners();
      
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.success('âœ… Sensorå›¾ç‰‡æµ‹è¯•å®Œæˆ', type: LogType.debug);
      _logState?.info('ğŸ“Š å›¾ç‰‡å¤§å°: $_expectedTotalBytes å­—èŠ‚', type: LogType.debug);
      _logState?.info('ğŸ“¦ æ€»åŒ…æ•°: ${_sensorDataList.length - 1}', type: LogType.debug);
      _logState?.info('â±ï¸  å®Œæˆæ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      
    } catch (e) {
      _logState?.error('å¤„ç†å®Œæˆçš„å›¾ç‰‡æ•°æ®æ—¶å‡ºé”™: $e', type: LogType.debug);
      _retrySensorTest();
    }
  }

  /// é‡è¯•sensoræµ‹è¯•
  void _retrySensorTest() async {
    _logState?.warning('ğŸ”„ å‡†å¤‡é‡è¯•Sensoræµ‹è¯•...', type: LogType.debug);
    
    // å…ˆåœæ­¢å½“å‰æµ‹è¯•
    await _stopSensorTestInternal();
    
    // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
    await Future.delayed(const Duration(seconds: 2));
    
    // é‡æ–°å¼€å§‹æµ‹è¯•
    await _startSensorTestWithRetry();
  }

  /// é‡ç½®å›¾ç‰‡ç¼“å†²åŒº
  void _resetImageBuffer() {
    _expectedTotalBytes = null;
    _imageBuffer.clear();
    _lastPacketTime = null;
    _sensorTimeoutTimer?.cancel();
    _packetTimeoutTimer?.cancel();
  }

  /// é‡ç½®sensoræµ‹è¯•çŠ¶æ€
  void _resetSensorTest() {
    _isSensorTesting = false;
    _showSensorDialog = false;
    _sensorRetryCount = 0;
    _resetImageBuffer();
    notifyListeners();
  }

  /// å†…éƒ¨åœæ­¢sensoræµ‹è¯•æ–¹æ³•
  Future<void> _stopSensorTestInternal() async {
    try {
      final stopCommand = ProductionTestCommands.createSensorCommand(ProductionTestCommands.sensorOptStop);
      await _serialService.sendCommandAndWaitResponse(
        stopCommand,
        timeout: const Duration(seconds: 5),
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );
      
      await _sensorDataSubscription?.cancel();
      _sensorDataSubscription = null;
      _resetImageBuffer();
      
    } catch (e) {
      _logState?.warning('åœæ­¢sensoræµ‹è¯•æ—¶å‡ºé”™: $e', type: LogType.debug);
    }
  }

  /// å…³é—­Sensoræµ‹è¯•å¼¹çª—
  void closeSensorDialog() {
    _showSensorDialog = false;
    notifyListeners();
  }

  /// æ¸…ç©ºSensoræ•°æ®
  void clearSensorData() {
    _sensorDataList.clear();
    notifyListeners();
  }

  /// æ‰‹åŠ¨æ‰§è¡ŒSensoræµ‹è¯•ï¼ˆç”¨äºæ‰‹åŠ¨æµ‹è¯•æŒ‰é’®ï¼‰
  Future<void> runManualSensorTest() async {
    final success = await startSensorTest();
    } catch (e) {
      _logState?.error('å¯åŠ¨Sensoræµ‹è¯•å¼‚å¸¸: $e', type: LogType.debug);
      await Future.delayed(const Duration(seconds: 2));
      return _startSensorTestWithRetry();
    }
  }

  /// åœæ­¢IMUæµ‹è¯•
  Future<bool> stopIMUTest() async {
    if (!_isIMUTesting) {
      _logState?.warning('[IMU] æœªåœ¨æµ‹è¯•ä¸­', type: LogType.debug);
      return false;
    }

    try {
      // å‘é€åœæ­¢IMUæµ‹è¯•å‘½ä»¤ (0x0B, 0x01)
      _logState?.info('ğŸ›‘ å‘é€åœæ­¢IMUæµ‹è¯•å‘½ä»¤', type: LogType.debug);
      
      final stopCommand = ProductionTestCommands.createIMUCommand(ProductionTestCommands.imuOptStopData);
      final stopCommandHex = stopCommand.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
      _logState?.info('ğŸ“¤ å‘é€: [$stopCommandHex] (${stopCommand.length} bytes)', type: LogType.debug);

      final stopResponse = await _serialService.sendCommandAndWaitResponse(
        stopCommand,
        timeout: const Duration(seconds: 5),
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (stopResponse != null && !stopResponse.containsKey('error')) {
        _logState?.success('âœ… åœæ­¢IMUæµ‹è¯•æˆåŠŸ', type: LogType.debug);
        
        // åœæ­¢æ•°æ®ç›‘å¬
        await _imuDataSubscription?.cancel();
        _imuDataSubscription = null;
        
        _isIMUTesting = false;
        notifyListeners();
        
        _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
        _logState?.success('âœ… IMUæµ‹è¯•ç»“æŸ', type: LogType.debug);
        _logState?.info('ğŸ“Š æ€»å…±æ”¶åˆ° ${_imuDataList.length} æ¡IMUæ•°æ®', type: LogType.debug);
        _logState?.info('â±ï¸  ç»“æŸæ—¶é—´: ${DateTime.now().toString()}', type: LogType.debug);
        _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
        
        return true;
      } else {
        _logState?.error('âŒ åœæ­¢IMUæµ‹è¯•å¤±è´¥: ${stopResponse?['error'] ?? 'æ— å“åº”'}', type: LogType.debug);
        return false;
      }
    } catch (e) {
      _logState?.error('åœæ­¢IMUæµ‹è¯•å¼‚å¸¸: $e', type: LogType.debug);
      return false;
    }
  }

  /// å¼€å§‹ç›‘å¬IMUæ•°æ®
  void _startIMUDataListener() {
    _imuDataSubscription = _serialService.dataStream.listen((data) {
      try {
        // ç›´æ¥æ£€æŸ¥payloadç¬¬ä¸€ä¸ªå­—èŠ‚æ˜¯å¦æ˜¯IMU CMD (0x0B)
        if (data.isNotEmpty && data[0] == ProductionTestCommands.cmdIMU) {
          final imuResult = ProductionTestCommands.parseIMUResponse(data);
          if (imuResult != null) {
            // æ·»åŠ æ—¶é—´æˆ³å’Œç´¢å¼•
            imuResult['timestamp'] = DateTime.now().toString();
            imuResult['index'] = _imuDataList.length + 1;
            
            _imuDataList.add(imuResult);
            notifyListeners();
            
            final payloadHex = data.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
            _logState?.info('ğŸ“¥ IMUæ•°æ® #${imuResult['index']}: [$payloadHex] (${data.length} bytes)', type: LogType.debug);
            
            // æ˜¾ç¤ºè§£æåçš„å¯è¯»æ•°æ®
            if (imuResult.containsKey('accel_x')) {
              _logState?.info('   ğŸ“Š åŠ é€Ÿåº¦: X=${imuResult['accel_x']?.toStringAsFixed(3)}, Y=${imuResult['accel_y']?.toStringAsFixed(3)}, Z=${imuResult['accel_z']?.toStringAsFixed(3)}', type: LogType.debug);
              _logState?.info('   ğŸ”„ é™€èºä»ª: X=${imuResult['gyro_x']?.toStringAsFixed(3)}, Y=${imuResult['gyro_y']?.toStringAsFixed(3)}, Z=${imuResult['gyro_z']?.toStringAsFixed(3)}', type: LogType.debug);
            }
          }
        }
      } catch (e) {
        _logState?.warning('âš ï¸  è§£æIMUæ•°æ®æ—¶å‡ºé”™: $e', type: LogType.debug);
      }
    });
  }

  /// å…³é—­IMUæµ‹è¯•å¼¹çª—
  void closeIMUDialog() {
    _showIMUDialog = false;
    notifyListeners();
  }

  /// æ¸…ç©ºIMUæ•°æ®
  void clearIMUData() {
    _imuDataList.clear();
    notifyListeners();
  }

  /// è“ç‰™MACåœ°å€çƒ§å½•
  Future<bool> burnBluetoothMac(String macAddress) async {
    if (!_serialService.isConnected) {
      _logState?.error('[è“ç‰™MAC] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return false;
    }

    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ“¡ å¼€å§‹è“ç‰™MACåœ°å€çƒ§å½•', type: LogType.debug);
      _logState?.info('ğŸ·ï¸  MACåœ°å€: $macAddress', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);

      // è§£æMACåœ°å€å­—ç¬¦ä¸²ä¸ºå­—èŠ‚æ•°ç»„
      List<String> macParts = macAddress.split(':');
      if (macParts.length != 6) {
        _logState?.error('âŒ MACåœ°å€æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º XX:XX:XX:XX:XX:XX æ ¼å¼', type: LogType.debug);
        return false;
      }

      List<int> macBytes = [];
      for (String part in macParts) {
        try {
          int byte = int.parse(part, radix: 16);
          macBytes.add(byte);
        } catch (e) {
          _logState?.error('âŒ MACåœ°å€æ ¼å¼é”™è¯¯ï¼Œæ— æ³•è§£æ: $part', type: LogType.debug);
          return false;
        }
      }

      // å‘é€è“ç‰™MACçƒ§å½•å‘½ä»¤ (0x0D, 0x00, 6å­—èŠ‚MAC)
      _logState?.info('ğŸ”„ å‘é€è“ç‰™MACçƒ§å½•å‘½ä»¤', type: LogType.debug);
      
      final burnCommand = ProductionTestCommands.createBluetoothMacCommand(
        ProductionTestCommands.bluetoothOptBurnMac, 
        macAddress: macBytes
      );
      final burnCommandHex = burnCommand.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
      _logState?.info('ğŸ“¤ å‘é€: [$burnCommandHex] (${burnCommand.length} bytes)', type: LogType.debug);

      final burnResponse = await _serialService.sendCommandAndWaitResponse(
        burnCommand,
        timeout: const Duration(seconds: 5),
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (burnResponse != null && !burnResponse.containsKey('error')) {
        // è§£æå“åº”
        final payload = burnResponse['payload'] as Uint8List;
        final bluetoothResult = ProductionTestCommands.parseBluetoothMacResponse(payload);
        
        if (bluetoothResult != null && bluetoothResult['success'] == true) {
          _logState?.success('âœ… è“ç‰™MACåœ°å€çƒ§å½•æˆåŠŸ', type: LogType.debug);
          if (bluetoothResult.containsKey('message')) {
            _logState?.info('   ğŸ“ ${bluetoothResult['message']}', type: LogType.debug);
          }
        } else {
          _logState?.error('âŒ è“ç‰™MACåœ°å€çƒ§å½•å¤±è´¥: ${bluetoothResult?['error'] ?? 'è§£æå“åº”å¤±è´¥'}', type: LogType.debug);
          return false;
        }
      } else {
        _logState?.error('âŒ è“ç‰™MACåœ°å€çƒ§å½•å¤±è´¥: ${burnResponse?['error'] ?? 'æ— å“åº”'}', type: LogType.debug);
        return false;
      }

      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      return true;
    } catch (e) {
      _logState?.error('è“ç‰™MACçƒ§å½•å¼‚å¸¸: $e', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      return false;
    }
  }

  /// è¯»å–è“ç‰™MACåœ°å€
  Future<String?> readBluetoothMac() async {
    if (!_serialService.isConnected) {
      _logState?.error('[è“ç‰™MAC] ä¸²å£æœªè¿æ¥', type: LogType.debug);
      return null;
    }

    try {
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      _logState?.info('ğŸ“¡ å¼€å§‹è¯»å–è“ç‰™MACåœ°å€', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);

      // å‘é€è¯»å–è“ç‰™MACå‘½ä»¤ (0x0D, 0x01)
      _logState?.info('ğŸ”„ å‘é€è¯»å–è“ç‰™MACå‘½ä»¤', type: LogType.debug);
      
      final readCommand = ProductionTestCommands.createBluetoothMacCommand(ProductionTestCommands.bluetoothOptReadMac);
      final readCommandHex = readCommand.map((b) => b.toRadixString(16).toUpperCase().padLeft(2, '0')).join(' ');
      _logState?.info('ğŸ“¤ å‘é€: [$readCommandHex] (${readCommand.length} bytes)', type: LogType.debug);

      final readResponse = await _serialService.sendCommandAndWaitResponse(
        readCommand,
        timeout: const Duration(seconds: 5),
        moduleId: ProductionTestCommands.moduleId,
        messageId: ProductionTestCommands.messageId,
      );

      if (readResponse != null && !readResponse.containsKey('error')) {
        // è§£æå“åº”
        final payload = readResponse['payload'] as Uint8List;
        final bluetoothResult = ProductionTestCommands.parseBluetoothMacResponse(payload);
        
        if (bluetoothResult != null && bluetoothResult['success'] == true && bluetoothResult.containsKey('mac')) {
          final macAddress = bluetoothResult['mac'] as String;
          _logState?.success('âœ… è¯»å–è“ç‰™MACåœ°å€æˆåŠŸ: $macAddress', type: LogType.debug);
          _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
          return macAddress;
        } else {
          _logState?.error('âŒ è¯»å–è“ç‰™MACåœ°å€å¤±è´¥: ${bluetoothResult?['error'] ?? 'è§£æå“åº”å¤±è´¥'}', type: LogType.debug);
        }
      } else {
        _logState?.error('âŒ è¯»å–è“ç‰™MACåœ°å€å¤±è´¥: ${readResponse?['error'] ?? 'æ— å“åº”'}', type: LogType.debug);
      }

      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      return null;
    } catch (e) {
      _logState?.error('è¯»å–è“ç‰™MACå¼‚å¸¸: $e', type: LogType.debug);
      _logState?.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', type: LogType.debug);
      return null;
    }
  }

  @override
  void dispose() {
    _sensorDataSubscription?.cancel();
    _imuDataSubscription?.cancel();
    _sensorTimeoutTimer?.cancel();
    _packetTimeoutTimer?.cancel();
    _serialService.dispose();
    super.dispose();
  }
}
